<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER VAULT | NEURAL SYSTEM v8.0</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&display=swap" rel="stylesheet">
    <!-- Phosphor Icons for cleaner icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <!-- Model Viewer for 3D Models -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --bg-core: #020204;
            --bg-panel: rgba(10, 12, 16, 0.9);
            --border-base: rgba(0, 243, 255, 0.15);
            --border-glow: rgba(0, 243, 255, 0.4);
            --accent: #00f3ff;
            --c-green: #00ff9d;
            --c-alert: #ff0055;
            --c-warn: #ffcc00;
            --font-main: 'JetBrains Mono', monospace;
            --card-scale: 1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background-color: var(--bg-core);
            font-family: var(--font-main);
            height: 100vh;
            overflow: hidden;
            color: #e0e0e0;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        /* --- 全局背景网格 --- */
        .grid-floor {
            position: absolute;
            width: 300%;
            height: 300%;
            top: -100%;
            left: -100%;
            background-image:
                linear-gradient(rgba(0, 243, 255, 0.07) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.07) 1px, transparent 1px);
            background-size: 80px 80px;
            transform: perspective(1000px) rotateX(60deg) translateY(0px) translateZ(-300px);
            animation: gridMove 20s linear infinite;
            z-index: -2;
            pointer-events: none;
            mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 30%, rgba(0, 0, 0, 0) 80%);
            transition: opacity 0.5s;
        }

        @keyframes gridMove {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 0 80px;
            }
        }

        .crt-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10000;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 3px, 4px 100%;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
            opacity: 0.7;
        }

        /* --- 主视口 --- */
        .viewport-container {
            display: flex;
            height: 100%;
            width: 100%;
            padding: 20px;
            gap: 25px;
            position: relative;
            z-index: 1;
            transition: opacity 0.5s, filter 0.5s;
        }

        .viewport-container.hidden {
            opacity: 0;
            pointer-events: none;
            filter: blur(10px);
            transform: scale(0.95);
        }

        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 2px;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 280px;
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-base);
            display: flex;
            flex-direction: column;
            box-shadow: 15px 0 40px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 100;
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 25px), calc(100% - 25px) 100%, 0 100%);
        }

        .sidebar::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--accent);
            box-shadow: 3px 0 20px var(--accent);
        }

        .logo {
            padding: 35px 28px;
            font-size: 20px;
            font-weight: 800;
            letter-spacing: 3px;
            border-bottom: 1px solid var(--border-base);
            color: #fff;
            text-shadow: 0 0 15px var(--accent);
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(to right, rgba(0, 243, 255, 0.08), transparent);
            cursor: pointer;
            transition: 0.3s;
        }

        .logo:hover {
            background: rgba(0, 243, 255, 0.15);
            text-shadow: 0 0 25px var(--accent);
        }

        .logo span {
            color: var(--accent);
            animation: pulse 2s infinite;
        }

        .nav-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px 0;
        }

        .nav-group-header {
            padding: 15px 28px 8px;
            font-size: 10px;
            color: #555;
            font-weight: 800;
            letter-spacing: 2px;
        }

        .nav-parent-header {
            padding: 14px 28px;
            color: #888;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 3px solid transparent;
            transition: 0.2s;
            cursor: pointer;
        }

        .nav-parent-header:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.03);
            padding-left: 32px;
        }

        .nav-parent.active-parent .nav-parent-header {
            color: #fff;
            border-left-color: var(--accent);
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.1), transparent);
            text-shadow: 0 0 8px var(--accent);
        }

        .nav-sub-list {
            display: none;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.03);
        }

        .nav-parent.expanded .nav-sub-list {
            display: block;
            animation: slideDown 0.2s ease-out;
        }

        .nav-sub-item {
            padding: 12px 28px 12px 50px;
            font-size: 12px;
            color: #666;
            cursor: pointer;
            position: relative;
            transition: 0.2s;
        }

        .nav-sub-item:hover {
            color: var(--accent);
            transform: translateX(5px);
        }

        .nav-sub-item.active {
            color: var(--accent);
            background: rgba(0, 243, 255, 0.05);
            font-weight: 600;
        }

        .nav-sub-item.active::after {
            content: '◀';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
        }

        /* --- Main Content --- */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-base);
            box-shadow: -15px 0 40px rgba(0, 0, 0, 0.6);
            position: relative;
            z-index: 50;
            border-top: 2px solid var(--border-base);
        }

        .main::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            width: 200px;
            height: 2px;
            background: var(--accent);
            box-shadow: 0 0 20px var(--accent);
            z-index: 2;
        }

        .header {
            height: 75px;
            border-bottom: 1px solid var(--border-base);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 100;
        }

        .page-title {
            font-size: 26px;
            font-weight: 800;
            letter-spacing: 2px;
            color: #fff;
            text-shadow: 2px 2px 0px rgba(0, 243, 255, 0.2);
        }

        .page-subtitle {
            font-size: 12px;
            color: var(--accent);
            opacity: 0.8;
            letter-spacing: 1px;
            margin-left: 10px;
        }

        .search-box {
            position: relative;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-base);
            padding: 8px 15px;
            width: 280px;
            transform: skewX(-15deg);
        }

        .search-suggestions {
            position: absolute;
            top: calc(100% + 15px);
            left: -10px;
            right: -10px;
            background: rgba(8, 10, 14, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-top: 2px solid var(--accent);
            max-height: 450px;
            overflow-y: auto;
            z-index: 2000;
            transform: skewX(15deg);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px rgba(0, 243, 255, 0.15);
            display: none;
            scrollbar-width: thin;
            scrollbar-color: var(--accent) #000;
        }

        .search-suggestions::-webkit-scrollbar {
            width: 4px;
        }

        .search-suggestions::-webkit-scrollbar-thumb {
            background: var(--accent);
        }

        .search-suggestions::-webkit-scrollbar-track {
            background: #000;
        }

        .search-suggestions.active {
            display: block;
        }

        .suggestion-section {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .suggestion-section:last-child {
            border-bottom: none;
        }

        .suggestion-section-title {
            font-size: 10px;
            color: var(--accent);
            letter-spacing: 2px;
            margin-bottom: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            border-left: 2px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .suggestion-item:hover {
            background: rgba(0, 243, 255, 0.1);
            border-left-color: var(--accent);
            color: #fff;
        }

        .suggestion-item-icon {
            font-size: 14px;
            color: var(--accent);
            opacity: 0.7;
        }

        .suggestion-item-text {
            flex: 1;
            font-size: 11px;
            color: #ccc;
        }

        .suggestion-item-meta {
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
        }

        .suggestion-item:hover .suggestion-item-meta {
            color: var(--accent);
        }

        /* Retro Typing Animation */
        @keyframes typeGlow {
            0% {
                text-shadow: 0 0 2px var(--accent);
                opacity: 0.9;
            }

            50% {
                text-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent);
                opacity: 1;
            }

            100% {
                text-shadow: 0 0 2px var(--accent);
                opacity: 0.9;
            }
        }

        .search-box input {
            transform: skewX(15deg);
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            width: 100%;
            outline: none;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--accent);
            caret-color: var(--c-alert);
            text-transform: uppercase;
        }

        .search-box input:focus {
            animation: typeGlow 1.5s infinite alternate;
        }

        /* Retro Placeholder */
        ::placeholder {
            color: rgba(0, 243, 255, 0.4);
            text-shadow: none;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            letter-spacing: 1px;
        }

        /* User Profile / Upload Trigger */
        .user-profile-box {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-base);
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
            position: relative;
        }

        .user-profile-box:hover {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 15px var(--accent);
        }

        .user-profile-box::after {
            content: '+';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 10px;
            background: var(--bg-core);
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .toolbar {
            height: 60px;
            border-bottom: 1px solid var(--border-base);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            background: rgba(255, 255, 255, 0.01);
        }

        .filter-chip {
            font-size: 11px;
            padding: 6px 18px;
            border: 1px solid var(--border-base);
            cursor: pointer;
            color: #888;
            transition: 0.2s;
            background: rgba(0, 0, 0, 0.3);
            margin-right: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .filter-chip:hover {
            color: #fff;
            border-color: rgba(255, 255, 255, 0.4);
        }

        .filter-chip.active {
            background: rgba(0, 243, 255, 0.1);
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.15);
            font-weight: 600;
        }

        .grid-content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            overflow-x: hidden;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(calc(260px * var(--card-scale)), 1fr));
            gap: 30px;
            align-content: start;
            justify-content: space-between;
        }

        .card {
            background: rgba(18, 20, 24, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
            width: 100%;
            height: calc(320px * var(--card-scale));
            display: flex;
            flex-direction: column;
            position: relative;
            cursor: pointer;
            transition: box-shadow 0.3s, border-color 0.3s;
        }

        .card:hover {
            border-color: var(--accent);
            box-shadow: 0 30px 50px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 243, 255, 0.15);
            z-index: 10;
        }

        .card-cover {
            height: 180px;
            width: 100%;
            position: relative;
            overflow: hidden;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            background: #050505;
        }

        .card-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.6;
            transition: 0.5s;
            filter: grayscale(0.8);
        }

        .card:hover .card-img {
            opacity: 1;
            transform: scale(1.1);
            filter: grayscale(0);
        }

        .card-type-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--accent);
            color: var(--accent);
            font-size: 9px;
            padding: 3px 6px;
            z-index: 5;
            letter-spacing: 1px;
        }

        .card-body {
            padding: 18px;
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01) 0%, rgba(0, 0, 0, 0.5) 100%);
        }

        .card-title {
            font-size: 15px;
            color: #fff;
            margin-bottom: 8px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tag-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .tag-tiny {
            font-size: 10px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #999;
        }

        .card-footer {
            margin-top: auto;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            font-size: 11px;
            color: #666;
        }

        .stat-val {
            color: var(--accent);
            font-weight: bold;
            margin-left: 4px;
        }

        /* --- Modal System --- */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-panel {
            width: 1000px;
            height: 650px;
            background: rgba(10, 11, 14, 0.98);
            border: 1px solid var(--accent);
            display: flex;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 0 100px rgba(0, 243, 255, 0.05);
            position: relative;
        }

        .modal-overlay.active .modal-panel {
            transform: scale(1);
            opacity: 1;
        }

        .modal-panel.expanded {
            width: 95vw;
            height: 90vh;
        }

        .close-btn {
            position: absolute;
            top: -20px;
            right: -20px;
            width: 40px;
            height: 40px;
            background: #000;
            border: 1px solid var(--accent);
            color: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2020;
            font-size: 20px;
            transition: 0.3s;
        }

        .close-btn:hover {
            background: var(--accent);
            color: #000;
            transform: rotate(90deg);
        }

        .expand-btn {
            position: absolute;
            top: -20px;
            right: 30px;
            width: 80px;
            height: 40px;
            background: #000;
            border: 1px solid var(--border-base);
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2020;
            font-size: 10px;
            transition: 0.3s;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .expand-btn:hover {
            color: var(--accent);
            border-color: var(--accent);
        }

        /* Modal Content Layout */
        .modal-gallery {
            width: 65%;
            background: #000;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
            position: relative;
        }

        .main-view {
            flex: 1;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            position: relative;
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
        }

        .media-object {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.5s;
            display: none;
        }

        .media-object.active {
            display: block;
            opacity: 1;
        }

        /* Model Viewer Styles */
        model-viewer {
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        model-viewer::part(default-progress-bar) {
            display: none;
        }

        /* PDF/Text Reader Styles */
        .pdf-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: #fff;
        }

        .text-reader-container {
            width: 100%;
            height: 100%;
            display: flex;
            background: #0a0a0c;
            color: #ccc;
        }

        .text-toc {
            width: 200px;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.3);
        }

        .toc-item {
            padding: 8px 0;
            border-bottom: 1px solid #222;
            cursor: pointer;
            transition: 0.2s;
        }

        .toc-item:hover {
            color: var(--accent);
            padding-left: 5px;
        }

        .text-content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .text-content h1 {
            color: var(--accent);
            margin-bottom: 20px;
            border-bottom: 1px dashed var(--accent);
            padding-bottom: 10px;
        }

        .text-content p {
            margin-bottom: 15px;
        }


        .nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            transition: 0.3s;
            opacity: 0.6;
        }

        .nav-btn:hover {
            opacity: 1;
        }

        .nav-btn.prev {
            left: 0;
        }

        .nav-btn.next {
            right: 0;
        }

        .arrow-graphic {
            width: 20px;
            height: 20px;
            border-top: 3px solid var(--accent);
            border-left: 3px solid var(--accent);
            transform: rotate(-45deg);
            position: relative;
            box-shadow: -2px -2px 5px rgba(0, 243, 255, 0.3);
        }

        .nav-btn.next .arrow-graphic {
            transform: rotate(135deg);
            box-shadow: -2px -2px 5px rgba(0, 243, 255, 0.3);
        }

        .thumb-strip {
            height: 0;
            opacity: 0;
            background: rgba(5, 5, 5, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 0 20px;
            transition: 0.3s;
            overflow: hidden;
        }

        .thumb-strip.active {
            height: 80px;
            opacity: 1;
        }

        .thumb-item {
            width: 60px;
            height: 45px;
            border: 1px solid #333;
            cursor: pointer;
            opacity: 0.4;
            transition: 0.3s;
            position: relative;
        }

        .thumb-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: grayscale(1);
        }

        .thumb-item:hover,
        .thumb-item.active {
            border-color: var(--accent);
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
        }

        .thumb-item.active img {
            filter: grayscale(0);
        }

        .modal-info {
            width: 35%;
            padding: 40px;
            background: rgba(20, 20, 25, 0.6);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .cyber-btn {
            background: rgba(0, 243, 255, 0.05);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 15px;
            font-family: var(--font-main);
            font-weight: 800;
            cursor: pointer;
            transition: 0.3s;
            margin-top: auto;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .cyber-btn:hover {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 30px var(--accent);
        }

        /* --- FIXED LOADER (Red Style) --- */
        .cyber-loader {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: 0.25s ease;
        }

        .cyber-loader.active {
            opacity: 1;
            pointer-events: auto;
        }

        .loader-box {
            width: 380px;
            position: relative;
        }

        .loader-text-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--c-alert);
            margin-bottom: 8px;
            font-weight: 800;
            letter-spacing: 2px;
            text-shadow: 0 0 8px var(--c-alert);
            font-family: var(--font-main);
        }

        /* Container for the bar */
        .loader-bar-container {
            width: 100%;
            height: 24px;
            position: relative;
            padding: 3px 12px;
        }

        /* Brackets [ ] styling */
        .loader-bar-container::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 8px;
            height: 100%;
            border: 2px solid var(--c-alert);
            border-right: none;
        }

        .loader-bar-container::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            width: 8px;
            height: 100%;
            border: 2px solid var(--c-alert);
            border-left: none;
        }

        /* The Filling Bar */
        .loader-fill {
            height: 100%;
            width: 0%;
            background: var(--c-alert);
            /* Solid Red as in image */
            box-shadow: 0 0 15px var(--c-alert);
            position: relative;
            overflow: hidden;
        }

        /* Striped effect inside the bar */
        .loader-fill::after {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(90deg,
                    transparent 0px, transparent 4px,
                    rgba(0, 0, 0, 0.4) 4px, rgba(0, 0, 0, 0.4) 8px);
        }

        /* --- UPLOAD PANEL --- */
        .upload-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 500px;
            background: #0a0c10;
            border: 1px solid var(--accent);
            z-index: 3000;
            padding: 0;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: 0.3s;
            pointer-events: none;
        }

        .upload-panel.active {
            display: flex;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .up-header {
            padding: 15px 20px;
            background: rgba(0, 243, 255, 0.1);
            border-bottom: 1px solid var(--border-base);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            font-weight: bold;
        }

        .up-body {
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 11px;
            color: var(--accent);
            letter-spacing: 1px;
        }

        .cyber-input {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            color: var(--accent);
            padding: 10px;
            font-family: 'Courier New', monospace;
            outline: none;
            transition: 0.3s;
            font-size: 13px;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--accent);
            caret-color: var(--c-alert);
            font-weight: bold;
            text-transform: uppercase;
        }

        .cyber-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            background: rgba(0, 10, 20, 0.8);
            animation: typeGlow 1.5s infinite alternate;
        }

        .file-drop-zone {
            border: 1px dashed rgba(0, 243, 255, 0.3) !important;
            background: rgba(0, 20, 30, 0.3) !important;
            height: 120px !important;
            display: flex !important;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--color-text-dim) !important;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px !important;
            position: relative;
        }

        .file-drop-zone:hover {
            border-color: var(--accent);
            background: rgba(0, 243, 255, 0.05);
            color: var(--accent);
        }

        .file-drop-zone i {
            margin-bottom: 15px;
            font-size: 24px;
        }

        .file-drop-zone span {
            font-family: var(--font-mono);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .up-footer {
            padding: 20px;
            border-top: 1px solid #222;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* --- NEURAL GRAPH SYSTEM v7.0 --- */
        .graph-container {
            position: fixed;
            inset: 0;
            z-index: 500;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 90%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
            display: flex;
        }

        .graph-container.active {
            opacity: 1;
            pointer-events: auto;
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 1s;
        }

        #particleCanvas.active {
            opacity: 1;
        }

        .neural-settings-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 260px;
            background: rgba(10, 12, 16, 0.9);
            border: 1px solid var(--border-base);
            backdrop-filter: blur(10px);
            padding: 20px;
            z-index: 600;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: -10px 10px 30px rgba(0, 0, 0, 0.5);
            transform: translateX(120%);
            transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .graph-container.active .neural-settings-panel {
            transform: translateX(0);
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-label {
            font-size: 10px;
            color: var(--accent);
            font-weight: bold;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
            height: 4px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 0;
            box-shadow: 0 0 10px var(--accent);
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: #888;
            cursor: pointer;
            padding: 4px 0;
        }

        .filter-checkbox input {
            accent-color: var(--accent);
        }

        .filter-checkbox:hover {
            color: #fff;
        }

        .exit-neural-btn {
            padding: 12px;
            text-align: center;
            border: 1px solid var(--c-warn);
            color: var(--c-warn);
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
            margin-top: 10px;
            background: rgba(255, 204, 0, 0.05);
        }

        .exit-neural-btn:hover {
            background: var(--c-warn);
            color: #000;
            box-shadow: 0 0 20px var(--c-warn);
        }

        /* SVG Graph Styles */
        svg {
            width: 100%;
            height: 100%;
            cursor: grab;
            position: relative;
            z-index: 10;
        }

        svg:active {
            cursor: grabbing;
        }

        .node-group {
            cursor: pointer;
            transition: 0.2s;
        }

        .node-circle {
            stroke: #fff;
            stroke-width: 1px;
            transition: 0.3s;
            fill: #000;
        }

        .node-text {
            font-family: var(--font-main);
            font-size: 10px;
            fill: #aaa;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        /* Node Dimming / Highlighting Logic */
        .node-group.dimmed {
            opacity: 0.1;
        }

        .node-group.highlighted {
            opacity: 1;
        }

        .node-group.highlighted .node-circle {
            stroke: var(--accent);
            stroke-width: 3px;
            filter: drop-shadow(0 0 15px var(--accent));
        }

        .node-group.highlighted .node-text {
            fill: #fff;
            font-weight: bold;
            opacity: 1;
            font-size: 12px;
        }

        .link {
            stroke: rgba(0, 243, 255, 0.1);
            stroke-width: 1px;
            transition: 0.3s;
        }

        .link.dimmed {
            opacity: 0.05;
        }

        .link.highlighted {
            stroke: var(--accent);
            stroke-width: 2px;
            opacity: 0.8;
        }

        /* Preview Image in Graph */
        .node-preview-img {
            pointer-events: auto;
            cursor: pointer;
            opacity: 0;
            transition: 0.3s;
            clip-path: circle(50% at 50% 50%);
            filter: grayscale(0.5);
        }

        .node-group:hover .node-preview-img {
            filter: grayscale(0);
            opacity: 1 !important;
            transform: scale(1.2);
        }

        .node-group.highlighted .node-preview-img {
            filter: grayscale(0);
            opacity: 1 !important;
        }

        .show-images .node-preview-img {
            opacity: 0.8;
        }

        /* --- NEW UPLOAD PANEL STYLES --- */
        .upload-panel {
            width: 80% !important;
            max-width: 1000px !important;
            height: 80vh !important;
            display: flex;
            flex-direction: column;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 0;
            flex: 1;
            overflow: hidden;
        }

        .up-left-col {
            padding: 30px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .up-right-col {
            background: rgba(0, 0, 0, 0.3);
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* PREVIEW CARD */
        .preview-label {
            font-size: 10px;
            color: var(--accent);
            letter-spacing: 2px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .preview-card {
            width: 100%;
            aspect-ratio: 4/5;
            background: rgba(10, 12, 16, 0.9);
            border: 1px solid var(--border-base);
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .preview-cover {
            height: 65%;
            width: 100%;
            background: #111;
            position: relative;
            overflow: hidden;
        }

        .preview-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-body {
            padding: 15px;
        }

        .preview-title {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-tags {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .preview-meta {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            font-family: var(--font-mono);
        }

        /* FILE LIST */
        .file-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.03);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid transparent;
        }

        .file-item.active {
            border-color: var(--accent);
            background: rgba(0, 243, 255, 0.05);
        }

        /* COVER SELECTOR */
        .cover-uploader {
            width: 100%;
            height: 100px;
            border: 1px dashed #444;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 11px;
            cursor: pointer;
            transition: 0.2s;
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .cover-uploader:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .cover-uploader span {
            pointer-events: none;
        }

        .tag-pill {
            background: rgba(0, 243, 255, 0.1);
            color: var(--accent);
            padding: 2px 6px;
            font-size: 9px;
            border-radius: 2px;
        }

        /* EDITOR PANEL */
        .editor-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: rgba(5, 7, 10, 0.98);
            backdrop-filter: blur(20px);
            z-index: 2000;
            display: none;
            flex-direction: column;
            animation: fadeIn 0.3s forwards;
        }

        .editor-panel.active {
            display: flex;
        }

        .editor-header {
            height: 60px;
            border-bottom: 2px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.1), transparent);
        }

        .editor-toolbar {
            height: 50px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 40px;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .tool-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #888;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: 0.2s;
            font-size: 14px;
        }

        .tool-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
        }

        .tool-separator {
            width: 1px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 5px;
        }

        .editor-workspace {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .editor-main {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            position: relative;
        }

        .editor-content,
        .editor-source {
            min-height: 100%;
            color: #fff;
            outline: none;
            font-size: 16px;
            line-height: 1.8;
            font-family: 'Courier New', monospace;
            /* Fallback, specific tweaks below */
        }

        .editor-source {
            display: none;
            width: 100%;
            height: 100%;
            background: #0a0c10;
            border: none;
            resize: none;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
            color: #ddd;
            padding: 20px;
            white-space: pre;
            tab-size: 4;
        }

        /* Typography overrides for editor content */
        .editor-content h1 {
            font-size: 2.5em;
            border-bottom: 1px solid var(--accent);
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .editor-content h2 {
            font-size: 1.8em;
            color: #fff;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .editor-content p {
            margin-bottom: 15px;
        }

        .editor-content blockquote {
            border-left: 3px solid var(--c-alert);
            padding-left: 20px;
            color: #aaa;
            margin: 20px 0;
            font-style: italic;
        }

        .editor-content ul,
        .editor-content ol {
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .editor-content img {
            max-width: 100%;
            border: 1px solid var(--accent);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            margin: 20px 0;
        }

        .editor-content pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border: 1px solid #333;
            color: #0f0;
            margin: 20px 0;
            overflow-x: auto;
        }

        .editor-sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.2);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .editor-sidebar input,
        .editor-sidebar select,
        .editor-sidebar textarea {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px;
            font-family: inherit;
            margin-bottom: 5px;
        }

        .editor-sidebar input:focus,
        .editor-sidebar select:focus,
        .editor-sidebar textarea:focus {
            border-color: var(--accent);
            outline: none;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
        }

        /* Editor Stats - Cyberpunk Retro Style */
        .editor-stats {
            display: flex;
            gap: 20px;
            align-items: center;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            letter-spacing: 1px;
        }

        .stat-item {
            position: relative;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-left: 2px solid var(--accent);
            color: #888;
            text-transform: uppercase;
            transform: skewX(-10deg);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
            transition: all 0.3s;
        }

        .stat-item:hover {
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            color: var(--accent);
        }

        .stat-item b {
            display: inline-block;
            transform: skewX(10deg);
            color: var(--accent);
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 243, 255, 0.6);
            margin-left: 8px;
            font-size: 12px;
            letter-spacing: 2px;
        }

        .stat-item::before {
            content: '>';
            position: absolute;
            left: 4px;
            color: var(--accent);
            opacity: 0.5;
            font-size: 8px;
        }

        /* Toolbar Dropdown & Advanced Editor Styles */
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px;
        }

        .toolbar-dropdown {
            position: relative;
            display: inline-block;
            z-index: 2002;
        }

        .dropdown-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: 0.2s;
        }

        .dropdown-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-color: var(--accent);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 180px;
            background: rgba(10, 15, 20, 0.98);
            backdrop-filter: blur(15px);
            border: 1px solid var(--accent);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            z-index: 2100;
            padding: 5px;
            border-radius: 4px;
            animation: fadeIn 0.1s ease-out;
            margin-top: 5px;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 2px;
        }

        .dropdown-item:hover {
            background: rgba(0, 243, 255, 0.1);
            color: var(--accent);
        }

        /* Color Picker */
        .color-picker-panel {
            padding: 5px;
            width: 220px;
        }

        .color-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }

        .color-tab {
            flex: 1;
            text-align: center;
            padding: 5px;
            font-size: 10px;
            cursor: pointer;
            color: #888;
            transition: 0.2s;
        }

        .color-tab:hover {
            color: #fff;
        }

        .color-tab.active {
            color: var(--accent);
            border-bottom: 2px solid var(--accent);
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .color-cell {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.1s;
            position: relative;
        }

        .color-cell:hover {
            transform: scale(1.2);
            border-color: #fff;
            z-index: 10;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .recent-colors {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Floating Toolbar */
        .floating-toolbar {
            position: fixed;
            background: rgba(5, 7, 10, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent);
            border-radius: 4px;
            padding: 5px;
            display: none;
            gap: 5px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.15);
            z-index: 2200;
            animation: fadeInUp 0.2s ease-out;
            pointer-events: auto;
        }

        .floating-toolbar.active {
            display: flex;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Active Button State */
        .tool-btn.active {
            background: rgba(0, 243, 255, 0.2);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 243, 255, 0.3);
        }

        /* Content additions */
        .editor-content blockquote {
            font-family: 'Georgia', serif;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 4px;
            border-left: 3px solid var(--accent);
            margin: 20px 0;
        }

        /* INLINE LINK PANEL */
        .link-panel {
            position: fixed;
            /* Changed to fixed for easier positioning */
            background: rgba(5, 7, 10, 0.98);
            border: 1px solid var(--accent);
            padding: 8px;
            display: none;
            gap: 5px;
            z-index: 2300;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border-radius: 4px;
        }

        .link-panel.active {
            display: flex;
        }

        .link-input {
            background: #000;
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            font-size: 12px;
            width: 200px;
            outline: none;
        }

        .link-input:focus {
            border-color: var(--accent);
        }

        /* Table Panel */
        .table-panel {
            position: fixed;
            background: rgba(5, 7, 10, 0.98);
            border: 1px solid var(--accent);
            padding: 15px;
            display: none;
            z-index: 2300;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            min-width: 200px;
        }

        .table-panel.active {
            display: block;
        }

        /* Table Toolbar */
        .table-toolbar {
            position: fixed;
            background: rgba(5, 7, 10, 0.98);
            border: 1px solid var(--accent);
            padding: 8px;
            display: none;
            gap: 5px;
            z-index: 2300;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            flex-wrap: wrap;
        }

        .table-toolbar.active {
            display: flex;
        }

        /* Table Context Menu */
        .table-context-menu {
            position: fixed;
            background: rgba(5, 7, 10, 0.98);
            border: 1px solid var(--accent);
            padding: 15px;
            display: none;
            z-index: 2400;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            min-width: 250px;
            max-width: 300px;
        }

        .table-context-menu.active {
            display: block;
        }

        .context-menu-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
        }

        .context-menu-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .context-menu-title {
            font-size: 10px;
            color: var(--accent);
            margin-bottom: 8px;
            letter-spacing: 1px;
            font-weight: bold;
        }

        /* Table Styles */
        .editor-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            border: 2px solid rgba(0, 243, 255, 0.5);
            position: relative;
            user-select: none;
        }

        .editor-content table td,
        .editor-content table th {
            border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 8px;
            min-width: 50px;
            min-height: 30px;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            cursor: cell;
        }

        .editor-content table th {
            background: rgba(0, 243, 255, 0.15);
            color: var(--accent);
            font-weight: bold;
        }

        /* Table Cell Selection */
        .editor-content table td.selected,
        .editor-content table th.selected {
            background: rgba(0, 243, 255, 0.3) !important;
            border: 2px solid var(--accent) !important;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .editor-content table td.selecting,
        .editor-content table th.selecting {
            background: rgba(0, 243, 255, 0.2) !important;
            border: 1px dashed var(--accent) !important;
        }

        /* Detail Page Table Styles (for article content) */
        .media-object table,
        #mediaContainer table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            border: 2px solid rgba(0, 243, 255, 0.6) !important;
            position: relative;
            background: rgba(0, 0, 0, 0.5);
        }

        .media-object table td,
        .media-object table th,
        #mediaContainer table td,
        #mediaContainer table th {
            border: 1px solid rgba(0, 243, 255, 0.4) !important;
            padding: 10px;
            min-width: 50px;
            min-height: 30px;
            position: relative;
            background: rgba(0, 0, 0, 0.4) !important;
        }

        .media-object table th,
        #mediaContainer table th {
            background: rgba(0, 243, 255, 0.2) !important;
            color: var(--accent) !important;
            font-weight: bold;
            border: 1px solid rgba(0, 243, 255, 0.5) !important;
        }

        .media-object table tr:hover td,
        .media-object table tr:hover th,
        #mediaContainer table tr:hover td,
        #mediaContainer table tr:hover th {
            background: rgba(0, 243, 255, 0.1) !important;
        }

        /* Table Resize Handles */
        .table-resize-handle {
            position: absolute;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .table-resize-handle.col-resize {
            top: 0;
            right: -3px;
            width: 6px;
            height: 100%;
            cursor: col-resize;
        }

        .table-resize-handle.row-resize {
            left: 0;
            bottom: -3px;
            width: 100%;
            height: 6px;
            cursor: row-resize;
        }

        .editor-content table:hover .table-resize-handle {
            opacity: 0.5;
        }

        .editor-content table .table-resize-handle:hover {
            opacity: 1;
        }

        /* IMAGE RESIZER OVERLAY */
        .resizer-overlay {
            position: absolute;
            border: 1px solid var(--accent);
            pointer-events: none;
            /* Allow clicks to pass through to editor usually, but handles catch events */
            z-index: 2200;
            display: none;
        }

        .resizer-overlay.active {
            display: block;
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--accent);
            border: 1px solid #000;
            pointer-events: auto;
            /* Handles are clickable */
            cursor: se-resize;
        }

        .rh-nw {
            top: -5px;
            left: -5px;
            cursor: nw-resize;
        }

        .rh-ne {
            top: -5px;
            right: -5px;
            cursor: ne-resize;
        }

        .rh-sw {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize;
        }

        .rh-se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }

        /* Media Layout Classes */
        .align-left {
            float: left;
            margin: 0 20px 10px 0;
        }

        .align-right {
            float: right;
            margin: 0 0 10px 20px;
        }

        .align-center {
            display: block;
            margin: 10px auto;
        }

        .align-inline {
            display: inline-block;
            vertical-align: bottom;
            margin: 0 5px;
        }

        /* Media Layout Toolkit (Floating above selected media) */
        .media-tools {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            display: none;
            gap: 5px;
            padding: 5px;
            border-radius: 4px;
            z-index: 2250;
            top: -40px;
            /* Above the image */
            left: 50%;
            transform: translateX(-50%);
        }

        .media-tools.active {
            display: flex;
        }

        .resizer-overlay.active .media-tools {
            display: flex;
            pointer-events: auto;
        }
    </style>
</head>

<body>

    <div class="grid-floor" id="floor"></div>
    <div class="crt-overlay"></div>

    <!-- Main Interface -->
    <div class="viewport-container" id="dashboard">
        <aside class="sidebar">
            <div class="logo" id="logoBtn" onclick="toggleNeuralMode()">
                <span>❖</span> CYBER VAULT
                <div style="font-size:9px; color:#555; margin-left:auto;">[NEURAL]</div>
            </div>
            <div class="nav-list" id="navList"></div>
        </aside>

        <main class="main">
            <header class="header">
                <div class="page-title" id="pageTitle">DASHBOARD<span class="page-subtitle" id="pageSubtitle">/
                        ONLINE</span></div>
                <div style="display: flex; gap: 15px; align-items: center;">
                    <div class="search-box" id="searchBox">
                        <input type="text" id="searchInput" placeholder="SEARCH DATABASE..." autocomplete="off">
                        <div class="search-suggestions" id="searchSuggestions"></div>
                    </div>
                    <!-- Upload / User Profile Trigger -->
                    <div class="user-profile-box" onclick="openUploadPanel()" title="UPLOAD DATA">
                        <i class="ph ph-upload-simple"></i>
                    </div>
                    <div class="user-profile-box" onclick="openEditor()" title="WRITE ARTICLE"
                        style="border-color: var(--c-green); color: var(--c-green);">
                        <i class="ph ph-pencil-simple"></i>
                    </div>
                </div>
            </header>

            <div class="toolbar">
                <div class="filter-group" id="filterContainer"></div>
                <div style="display: flex; align-items: center; gap: 10px; font-size: 11px; color: #666;">
                    <span>ZOOM_LENS</span>
                    <input type="range" id="zoomSlider" min="0.8" max="1.3" value="1" step="0.1"
                        style="width: 100px; accent-color: var(--accent);">
                </div>
            </div>

            <div class="grid-content" id="grid"></div>
        </main>
    </div>

    <!-- NEURAL GRAPH MODE CONTAINER -->
    <div class="graph-container" id="graphView">
        <canvas id="particleCanvas"></canvas>
        <!-- SVG injected here -->

        <div class="neural-settings-panel">
            <div
                style="font-size:14px; font-weight:bold; color:#fff; border-bottom:1px solid #333; padding-bottom:10px; margin-bottom:10px;">
                NEURAL_CONTROLS
            </div>

            <div class="setting-group">
                <div class="setting-label"><span>IMAGE SIZE</span><span id="valSize">40px</span></div>
                <input type="range" id="setImgSize" min="20" max="100" value="40" oninput="updateGraphSettings()">
            </div>

            <div class="setting-group">
                <div class="setting-label"><span>DENSITY</span><span id="valDensity">ALL</span></div>
                <input type="range" id="setDensity" min="10" max="100" value="100" oninput="updateGraphSettings()">
            </div>

            <div class="setting-group">
                <div class="setting-label"><span>VISUALS</span></div>
                <label class="filter-checkbox">
                    <input type="checkbox" id="setShowImages" checked onchange="updateGraphSettings()">
                    SHOW IMAGES
                </label>
                <label class="filter-checkbox">
                    <input type="checkbox" id="setParticles" checked onchange="toggleParticles()">
                    COSMIC PARTICLES
                </label>
            </div>

            <div class="setting-group">
                <div class="setting-label"><span>FILTER NODES</span></div>
                <div id="filterChecks"></div>
            </div>

            <div class="setting-group">
                <div class="setting-label"><span>BG COLOR</span></div>
                <input type="color" id="setBgColor" value="#1a1a2e"
                    style="width:100%; border:none; height:25px; cursor:pointer;" onchange="updateGraphBg()">
            </div>

            <div class="exit-neural-btn" onclick="toggleNeuralMode()">EXIT SYSTEM</div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="modal">
        <div class="modal-panel" id="modalPanel">
            <div class="close-btn" onclick="closeModal()">×</div>
            <div class="expand-btn" onclick="toggleFullscreen()">EXPAND</div>

            <div class="modal-gallery">
                <div class="card-scan" style="opacity: 0.15; z-index: 10; pointer-events: none;"></div>

                <!-- Fixed Loading Bar -->
                <div class="cyber-loader" id="mediaLoader">
                    <div class="loader-box">
                        <div class="loader-text-row">
                            <span>LOADING DATA...</span>
                            <span id="loadPercent">0%</span>
                        </div>
                        <div class="loader-bar-container">
                            <div class="loader-fill" id="loadBar"></div>
                        </div>
                    </div>
                </div>

                <div class="nav-btn prev" id="btnPrev" onclick="navigateMedia(-1)" style="display:none;">
                    <div class="arrow-graphic"></div>
                </div>
                <div class="nav-btn next" id="btnNext" onclick="navigateMedia(1)" style="display:none;">
                    <div class="arrow-graphic"></div>
                </div>
                <div class="main-view" id="mediaContainer"></div>
                <div class="thumb-strip" id="thumbStrip"></div>
            </div>

            <div class="modal-info">
                <div style="color:var(--accent); font-size:11px; letter-spacing:2px; margin-bottom:8px;">CLASSIFIED
                    ASSET</div>
                <div style="font-size:24px; font-weight:800; line-height:1.2; color:#fff; text-shadow: 0 0 10px rgba(255,255,255,0.2); margin-bottom: 20px; word-break: break-all;"
                    id="modalTitle">Title</div>
                <div
                    style="display:grid; grid-template-columns: 1fr 1fr; gap: 20px; border-top:1px solid rgba(255,255,255,0.1); padding-top:20px;">
                    <div>
                        <div style="color:#666; font-size:10px;">SIZE</div>
                        <div class="stat-val" id="modalSize" style="margin-left:0; font-size:14px;">0MB</div>
                    </div>
                    <div>
                        <div style="color:#666; font-size:10px;">VERSION</div>
                        <div class="stat-val" id="modalVer" style="margin-left:0; font-size:14px;">v.1.0</div>
                    </div>
                    <div>
                        <div style="color:#666; font-size:10px;">STATUS</div>
                        <div style="color:var(--c-green); font-weight:bold; font-size:14px;">ACTIVE</div>
                    </div>
                    <div>
                        <div style="color:#666; font-size:10px;">FORMAT</div>
                        <div class="stat-val" id="modalType" style="margin-left:0; font-size:14px; color:#fff;">DATA
                        </div>
                    </div>
                </div>
                <div style="margin-top:20px; font-size:12px; color:#888; line-height:1.6; flex:1; overflow-y:auto;"
                    id="modalDesc">
                    <p style="margin-bottom:10px;">> Analyzing packet header...</p>
                    <p>Asset verified. Security checksum valid. Contains high-resolution visual data and telemetry logs
                        from the targeted sector.</p>
                </div>
                <div class="cyber-btn">INITIATE DOWNLOAD</div>
            </div>
        </div>
    </div>

    <!-- Upload Panel -->
    <!-- Upload Panel (Redesigned) -->
    <div class="upload-panel" id="uploadPanel">
        <div class="up-header">
            <span>// UPLOAD_DATA_PACKET</span>
            <span style="cursor:pointer; color:var(--c-alert);" onclick="closeUploadPanel()">×</span>
        </div>

        <div class="upload-grid">
            <!-- LEFT: FORM -->
            <div class="up-left-col">
                <div class="form-group">
                    <div class="form-label">Title</div>
                    <input type="text" id="upTitle" class="cyber-input" placeholder="AUTO_EXTRACTED_FROM_FILENAME"
                        oninput="updatePreview()">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top:20px;">
                    <div class="form-group">
                        <div class="form-label">Category</div>
                        <select id="upCategory" class="cyber-input"
                            onchange="updateSubCats(); updatePreview();"></select>
                    </div>
                    <div class="form-group">
                        <div class="form-label">Sub-Routine</div>
                        <select id="upSub" class="cyber-input" onchange="updatePreview()"></select>
                    </div>
                </div>

                <div class="form-group" style="margin-top:20px;">
                    <div class="form-label">Description (Encyrpted Log)</div>
                    <textarea id="upDesc" class="cyber-input" style="height: 80px; resize: none;"
                        placeholder="ENTER BRIEF DESCRIPTION..." oninput="updatePreview()"></textarea>
                </div>

                <div class="form-group" style="margin-top:20px;">
                    <div class="form-label">Tags (Comma Separated)</div>
                    <input type="text" id="upTags" class="cyber-input" placeholder="cyber, secure, data..."
                        oninput="updatePreview()">
                </div>

                <div class="form-group" style="margin-top:20px;">
                    <div class="form-label">Cover Image</div>
                    <div class="cover-uploader" id="coverDrop" onclick="document.getElementById('coverInput').click()">
                        <span>CLICK TO SET COVER</span>
                        <input type="file" id="coverInput" style="display:none" accept="image/*"
                            onchange="handleCoverSelect(this)">
                    </div>
                </div>

                <div class="form-group" style="margin-top:20px;">
                    <div class="file-drop-zone" id="mainDropZone"
                        onclick="document.getElementById('fileInput').click()">
                        <i class="ph ph-cloud-arrow-up"
                            style="color:var(--accent); font-size: 32px; text-shadow: 0 0 10px var(--accent);"></i>
                        <span style="margin-top:10px; color:#fff;">CLICK TO UPLOAD ASSETS</span>
                        <span style="font-size:10px; color:#666; margin-top:5px;">JPG, PNG, WEBP (Max 5MB)</span>
                        <input type="file" id="fileInput" style="display:none" multiple
                            onchange="handleFileSelect(this)">
                    </div>
                </div>
            </div>

            <!-- RIGHT: PREVIEW -->
            <div class="up-right-col">
                <div class="preview-label">// LIVE_PREVIEW_RENDER_v9.0</div>

                <!-- CARD MOCKUP -->
                <div class="preview-card" id="previewCard">
                    <div class="card-type-badge" id="preType">DATA</div>
                    <div class="preview-cover">
                        <div class="card-scan"></div>
                        <img id="preImg" src="https://placehold.co/600x400/000/00f3ff?text=NO+PREVIEW"
                            style="opacity: 0.8;">
                    </div>
                    <div class="preview-body">
                        <div class="preview-title" id="preTitle">UNTITLED_ASSET</div>
                        <div class="preview-tags" id="preTags">
                            <span class="tag-pill">CYBER</span>
                            <span class="tag-pill">SECURE</span>
                        </div>
                        <div class="preview-meta">
                            <div class="pre-size">SIZE <span id="preSize" style="color:#fff;">0 MB</span></div>
                            <div class="pre-ver">VER <span style="color:#fff;">v.1.0</span></div>
                        </div>
                    </div>
                </div>

                <!-- FILE LIST -->
                <div class="preview-label" style="margin-top:20px;">// BATCH_QUEUE</div>
                <div class="file-list" id="fileList">
                    <div style="text-align:center; color:#444; padding:20px; font-size:10px;">NO FILES SELECTED</div>
                </div>
            </div>
        </div>

        <div class="up-footer">
            <div class="cyber-btn"
                style="width:100px; font-size:11px; padding:10px; background:transparent; color:#888; border-color:#444;"
                onclick="closeUploadPanel()">CANCEL_OP</div>
            <div class="cyber-btn" style="width:140px; font-size:11px; padding:10px;" onclick="submitUpload()">
                <i class="ph ph-upload-simple"></i> INITIATE_UPLOAD
            </div>
        </div>
    </div>

    <!-- Article Editor Panel -->
    <div class="editor-panel" id="editorPanel">
        <div class="editor-header">
            <div style="font-size: 18px; font-weight: bold; letter-spacing: 2px; color: var(--accent);">
                <span>//</span> NEURAL_AUTHORING_SYSTEM
            </div>
            <div style="display:flex; gap: 20px; align-items:center;">
                <div class="editor-stats" id="editorStats">
                    <span class="stat-item">WORDS: <b id="statWords">0</b></span>
                    <span class="stat-item">KV_IMG: <b id="statImg">0</b></span>
                </div>
                <div style="font-size: 10px; color: #666;">STATUS: <span style="color:var(--c-green)">ONLINE</span>
                </div>
                <div class="cyber-btn" onclick="closeEditor()"
                    style="width:auto; padding: 5px 15px; font-size: 12px; background: transparent; border-color: var(--c-alert); color: var(--c-alert);">
                    EXIT</div>
            </div>
        </div>

        <div class="editor-toolbar">
            <!-- Font Size -->
            <div class="toolbar-dropdown">
                <div class="dropdown-btn" onclick="event.stopPropagation(); toggleDropdown('fontSizeDropdown', event)">
                    Size <i class="ph ph-caret-down"></i>
                </div>
                <div class="dropdown-content" id="fontSizeDropdown">
                    <div class="dropdown-item" onclick="execCmd('fontSize', '1')">Small</div>
                    <div class="dropdown-item" onclick="execCmd('fontSize', '3')">Normal</div>
                    <div class="dropdown-item" onclick="execCmd('fontSize', '5')">Large</div>
                    <div class="dropdown-item" onclick="execCmd('fontSize', '7')">Huge</div>
                </div>
            </div>

            <!-- Color Format -->
            <div class="toolbar-dropdown">
                <div class="dropdown-btn" onclick="event.stopPropagation(); toggleDropdown('colorDropdown', event)">
                    Color <i class="ph ph-caret-down"></i>
                </div>
                <div class="dropdown-content" id="colorDropdown">
                    <div class="color-picker-panel">
                        <div class="color-tabs">
                            <div class="color-tab active" onclick="switchColorTab('fore')">Text</div>
                            <div class="color-tab" onclick="switchColorTab('back')">Highlight</div>
                        </div>
                        <div id="foreColorGrid" class="color-grid"></div>
                        <div id="backColorGrid" class="color-grid" style="display:none;"></div>
                        <div class="recent-colors">
                            <div style="font-size:9px; color:#666; margin-bottom:5px;">RECENT</div>
                            <div id="recentColors" class="color-grid" style="grid-template-columns: repeat(8, 1fr);">
                            </div>
                        </div>
                        <div class="dropdown-item" onclick="execCmd('removeFormat'); toggleDropdown('colorDropdown')"
                            style="margin-top:5px; justify-content:center; background:rgba(255,0,0,0.1); color:#ff5555;">
                            <i class="ph ph-eraser" style="margin-right:5px;"></i> Remove Color
                        </div>
                    </div>
                </div>
            </div>

            <div class="tool-separator"></div>

            <button class="tool-btn" data-cmd="bold" onclick="execCmd('bold')" title="Bold (Ctrl+B)"><b>B</b></button>
            <button class="tool-btn" data-cmd="italic" onclick="execCmd('italic')"
                title="Italic (Ctrl+I)"><i>I</i></button>
            <button class="tool-btn" data-cmd="underline" onclick="execCmd('underline')"
                title="Underline (Ctrl+U)"><u>U</u></button>
            <button class="tool-btn" data-cmd="strikeThrough" onclick="execCmd('strikeThrough')"
                title="Strikethrough"><s>S</s></button>

            <div class="tool-separator"></div>

            <button class="tool-btn" data-cmd="justifyLeft" onclick="execCmd('justifyLeft')" title="Align Left"><i
                    class="ph ph-text-align-left"></i></button>
            <button class="tool-btn" data-cmd="justifyCenter" onclick="execCmd('justifyCenter')" title="Align Center"><i
                    class="ph ph-text-align-center"></i></button>
            <button class="tool-btn" data-cmd="justifyRight" onclick="execCmd('justifyRight')" title="Align Right"><i
                    class="ph ph-text-align-right"></i></button>

            <div class="tool-separator"></div>

            <button class="tool-btn" data-cmd="insertUnorderedList" onclick="execCmd('insertUnorderedList')"
                title="Bullet List"><i class="ph ph-list-bullets"></i></button>
            <button class="tool-btn" data-cmd="insertOrderedList" onclick="execCmd('insertOrderedList')"
                title="Numbered List"><i class="ph ph-list-numbers"></i></button>
            <button class="tool-btn" onclick="execCmd('formatBlock', 'blockquote')" title="Quote"><i
                    class="ph ph-quotes"></i></button>
            <button class="tool-btn" onclick="insertCodeBlock()" title="Code Block"><i class="ph ph-code"></i></button>
            <button class="tool-btn" onclick="insertHorizontalRule()" title="Horizontal Line"><i class="ph ph-minus"></i></button>

            <div class="tool-separator"></div>

            <button class="tool-btn" onclick="showTablePanel()" title="Insert Table"><i class="ph ph-table"></i></button>
            <button class="tool-btn" onclick="showLinkPanel()" title="Link"><i class="ph ph-link"></i></button>
            <button class="tool-btn" onclick="triggerFileUpload('image')" title="Insert Image"><i
                    class="ph ph-image"></i></button>
            <button class="tool-btn" onclick="triggerFileUpload('video')" title="Insert Video"><i
                    class="ph ph-film-strip"></i></button>

            <div class="tool-separator"></div>
            <div class="tool-separator"></div>

            <button class="tool-btn" onclick="execCmd('undo')" title="Undo (Ctrl+Z)"><i
                    class="ph ph-arrow-u-up-left"></i></button>
            <button class="tool-btn" onclick="execCmd('redo')" title="Redo (Ctrl+Y)"><i
                    class="ph ph-arrow-u-up-right"></i></button>

            <div class="tool-separator"></div>

            <button class="tool-btn" id="btnSource" onclick="toggleSourceMode()" title="Source Code"><i
                    class="ph ph-code-block"></i></button>



            <!-- Inputs for file upload -->
            <input type="file" id="editorImgInput" style="display:none;" accept="image/*"
                onchange="handleEditorUpload(this, 'image')">
            <input type="file" id="editorVidInput" style="display:none;" accept="video/*"
                onchange="handleEditorUpload(this, 'video')">
        </div>

        <div class="editor-workspace">
            <div class="editor-main">
                <div class="editor-content" id="editorContent" contenteditable="true" spellcheck="false"
                    oninput="updateStats()">
                    <p><br></p>
                </div>
                <textarea class="editor-source" id="editorSource" spellcheck="false"></textarea>
                <div class="editor-source-highlight" id="editorSourceHighlight"></div>
                <div class="floating-toolbar" id="floatingToolbar">
                    <button class="tool-btn" onclick="execCmd('bold')" title="Bold"><b>B</b></button>
                    <button class="tool-btn" onclick="execCmd('italic')" title="Italic"><i>I</i></button>
                    <button class="tool-btn" onclick="execCmd('underline')" title="Underline"><u>U</u></button>
                    <button class="tool-btn" onclick="execCmd('foreColor', '#00f3ff')" title="Cyan Highlight"
                        style="color:#00f3ff;"><b>A</b></button>
                    <button class="tool-btn" onclick="execCmd('foreColor', '#ff0055')" title="Pink Highlight"
                        style="color:#ff0055;"><b>A</b></button>
                    <button class="tool-btn" onclick="execCmd('backColor', 'rgba(0, 243, 255, 0.2)')" title="Marker"
                        style="color:#00f3ff;"><i class="ph ph-highlighter"></i></button>
                    <button class="tool-btn" onclick="execCmd('backColor', 'rgba(255, 0, 85, 0.2)')" title="Marker"
                        style="color:#ff0055;"><i class="ph ph-highlighter"></i></button>
                    <div class="tool-separator"></div>
                    <button class="tool-btn" onclick="showLinkPanel()" title="Link"><i class="ph ph-link"></i></button>
                </div>

                <!-- Inline Link Panel -->
                <div class="link-panel" id="linkPanel">
                    <input type="text" class="link-input" id="linkInput" placeholder="https://...">
                    <button class="tool-btn" onclick="confirmLink()"><i class="ph ph-check"></i></button>
                    <button class="tool-btn" onclick="hideLinkPanel()"><i class="ph ph-x"></i></button>
                </div>

                <!-- Table Panel -->
                <div class="table-panel" id="tablePanel">
                    <div style="font-size: 10px; color: var(--accent); margin-bottom: 10px;">TABLE SIZE</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="font-size: 9px; color: #888;">ROWS</label>
                            <input type="number" id="tableRows" value="3" min="1" max="20" style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #fff;">
                        </div>
                        <div>
                            <label style="font-size: 9px; color: #888;">COLUMNS</label>
                            <input type="number" id="tableCols" value="3" min="1" max="20" style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #fff;">
                        </div>
                    </div>
                    <button class="tool-btn" onclick="insertTable()" style="width: 100%; margin-bottom: 5px;"><i class="ph ph-check"></i> INSERT</button>
                    <button class="tool-btn" onclick="hideTablePanel()" style="width: 100%; background: rgba(255,0,85,0.2); border-color: #ff0055; color: #ff0055;"><i class="ph ph-x"></i> CANCEL</button>
                </div>

                <!-- Table Toolbar (shown when table is selected) -->
                <div class="table-toolbar" id="tableToolbar">
                    <button class="tool-btn" onclick="tableAddRow('above')" title="Add Row Above"><i class="ph ph-arrow-up"></i></button>
                    <button class="tool-btn" onclick="tableAddRow('below')" title="Add Row Below"><i class="ph ph-arrow-down"></i></button>
                    <button class="tool-btn" onclick="tableAddCol('left')" title="Add Column Left"><i class="ph ph-arrow-left"></i></button>
                    <button class="tool-btn" onclick="tableAddCol('right')" title="Add Column Right"><i class="ph ph-arrow-right"></i></button>
                    <div class="tool-separator"></div>
                    <button class="tool-btn" onclick="tableDeleteRow()" title="Delete Row"><i class="ph ph-minus"></i></button>
                    <button class="tool-btn" onclick="tableDeleteCol()" title="Delete Column" style="font-weight: bold;">|</button>
                    <button class="tool-btn" onclick="tableDeleteTable()" title="Delete Table" style="color: var(--c-alert);"><i class="ph ph-trash"></i></button>
                </div>

                <!-- Table Context Menu (right-click menu) -->
                <div class="table-context-menu" id="tableContextMenu">
                    <div class="context-menu-section">
                        <div class="context-menu-title">ROW HEIGHT</div>
                        <input type="number" id="tableRowHeight" value="30" min="20" max="200" style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #fff; margin-bottom: 10px;">
                        <button class="tool-btn" onclick="applyTableRowHeight()" style="width: 100%; margin-bottom: 15px;">APPLY</button>
                    </div>
                    
                    <div class="context-menu-section">
                        <div class="context-menu-title">COLUMN WIDTH</div>
                        <input type="number" id="tableColWidth" value="100" min="50" max="500" style="width: 100%; padding: 5px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #fff; margin-bottom: 10px;">
                        <button class="tool-btn" onclick="applyTableColWidth()" style="width: 100%; margin-bottom: 15px;">APPLY</button>
                    </div>

                    <div class="context-menu-section">
                        <div class="context-menu-title">TEXT ALIGN</div>
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                            <button class="tool-btn" onclick="setTableCellAlign('left', 'cell')" title="Cell Left"><i class="ph ph-text-align-left"></i></button>
                            <button class="tool-btn" onclick="setTableCellAlign('center', 'cell')" title="Cell Center"><i class="ph ph-text-align-center"></i></button>
                            <button class="tool-btn" onclick="setTableCellAlign('right', 'cell')" title="Cell Right"><i class="ph ph-text-align-right"></i></button>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="tool-btn" onclick="setTableCellAlign('left', 'row')" title="Row Left" style="font-size: 9px;">ROW</button>
                            <button class="tool-btn" onclick="setTableCellAlign('center', 'row')" title="Row Center" style="font-size: 9px;">ROW</button>
                            <button class="tool-btn" onclick="setTableCellAlign('right', 'row')" title="Row Right" style="font-size: 9px;">ROW</button>
                        </div>
                    </div>

                    <div class="context-menu-section">
                        <div class="context-menu-title">CELL BACKGROUND</div>
                        <div class="color-picker-grid" id="tableColorPicker" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; margin-bottom: 10px;">
                            <!-- Colors will be generated by JS -->
                        </div>
                        <input type="color" id="tableCustomColor" value="#000000" style="width: 100%; height: 30px; margin-bottom: 10px; cursor: pointer;">
                        <button class="tool-btn" onclick="applyTableCellColor()" style="width: 100%;">APPLY COLOR</button>
                    </div>
                </div>

                <!-- Resizer Overlay -->
                <div class="resizer-overlay" id="resizeOverlay">
                    <div class="resize-handle rh-nw" data-corner="nw"></div>
                    <div class="resize-handle rh-ne" data-corner="ne"></div>
                    <div class="resize-handle rh-sw" data-corner="sw"></div>
                    <div class="resize-handle rh-se" data-corner="se"></div>

                    <div class="media-tools">
                        <button class="tool-btn" onclick="setMediaAlign('left')" title="Float Left"><i
                                class="ph ph-text-align-left"></i></button>
                        <button class="tool-btn" onclick="setMediaAlign('center')" title="Center"><i
                                class="ph ph-text-align-center"></i></button>
                        <button class="tool-btn" onclick="setMediaAlign('right')" title="Float Right"><i
                                class="ph ph-text-align-right"></i></button>
                        <button class="tool-btn" onclick="setMediaAlign('inline')" title="Inline"><i
                                class="ph ph-placeholder"></i></button>
                        <button class="tool-btn" onclick="deleteSelectedMedia()" title="Delete"
                            style="color:var(--c-alert);"><i class="ph ph-trash"></i></button>
                    </div>
                </div>
            </div>

            <div class="editor-sidebar">
                <div
                    style="color: var(--accent); font-size: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 10px;">
                    // METADATA_CONFIG
                </div>

                <div>
                    <label style="font-size: 10px; color: #888; display: block; margin-bottom: 5px;">TITLE</label>
                    <input type="text" id="artTitle" placeholder="Article Title...">
                </div>

                <div>
                    <label style="font-size: 10px; color: #888; display: block; margin-bottom: 5px;">CATEGORY</label>
                    <select id="artCategory">
                        <option value="blog-articles">BLOG / Articles</option>
                        <option value="blog-notes">BLOG / Notes</option>
                        <!-- Should be dynamically populated ideally, but hardcoded for now -->
                    </select>
                </div>

                <div>
                    <label style="font-size: 10px; color: #888; display: block; margin-bottom: 5px;">TAGS</label>
                    <input type="text" id="artTags" placeholder="cyber, neural, log...">
                </div>

                <div>
                    <label style="font-size: 10px; color: #888; display: block; margin-bottom: 5px;">COVER IMAGE
                        (OPTIONAL)</label>
                    <div class="cover-uploader" id="artCoverDrop" onclick="document.getElementById('artCoverInput').click()" style="margin-top: 5px;">
                        <span id="artCoverText">CLICK TO UPLOAD COVER</span>
                        <input type="file" id="artCoverInput" style="display:none" accept="image/*"
                            onchange="handleArticleCoverSelect(this)">
                    </div>
                    <div id="artCoverPreview" style="margin-top: 10px; display: none;">
                        <img id="artCoverPreviewImg" style="max-width: 100%; max-height: 150px; border: 1px solid var(--accent);">
                        <button onclick="clearArticleCover()" style="margin-top: 5px; padding: 5px 10px; background: rgba(255,0,85,0.2); border: 1px solid #ff0055; color: #ff0055; cursor: pointer; font-size: 10px;">REMOVE</button>
                    </div>
                </div>

                <div style="margin-top: auto;">
                    <div class="cyber-btn" onclick="handlePublish()" style="width: 100%; text-align: center;">
                        <i class="ph ph-paper-plane-right"></i> PUBLISH_TO_GRID
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const structure = [
            {
                group: 'MAIN DATABASE',
                children: [
                    {
                        id: 'env', name: 'ENVIRONMENTS', color: '#00f3ff',
                        subs: [
                            { id: 'neon', name: 'Neon City', tags: ['Night', 'Rain', 'Lights'] },
                            { id: 'waste', name: 'Wasteland', tags: ['Dust', 'Ruins', 'Sun'] }
                        ]
                    },
                    {
                        id: 'evidence', name: 'EVIDENCE', color: '#ff0055',
                        subs: [
                            { id: 'gallery', name: 'Scene Gallery', tags: ['Multi-View', 'Photos', 'Evidence'] },
                            { id: 'video', name: 'Surveillance', tags: ['Footage', 'CCTV', 'Night Vision'] }
                        ]
                    }
                ]
            },
            {
                group: 'ARCHIVES',
                children: [
                    {
                        id: 'docs', name: 'DOCUMENTS', color: '#ffcc00',
                        subs: [
                            { id: 'manuals', name: 'Manuals', tags: ['PDF', 'Blueprint', 'Tech'] },
                            { id: 'logs', name: 'Mission Logs', tags: ['Text', 'Report', 'Encrypted'] }
                        ]
                    }
                ]
            },
            {
                group: '3D ASSETS',
                children: [
                    {
                        id: 'models', name: 'MODELS', color: '#ff9900',
                        subs: [
                            { id: 'vehicles', name: 'Vehicles', tags: ['Cyber', 'Transport', 'Air'] },
                            { id: 'chars', name: 'Characters', tags: ['Droid', 'Humanoid', 'NPC'] }
                        ]
                    }
                ]
            },
            {
                group: 'AUDIO LOGS',
                children: [
                    {
                        id: 'audio', name: 'RECORDS', color: '#ff0055',
                        subs: [
                            { id: 'logs', name: 'Voice Logs', tags: ['Voice', 'Encrypted'] },
                            { id: 'music', name: 'Synthwave', tags: ['Music', 'Ambient'] }
                        ]
                    }
                ]
            },
            {
                group: 'NETWORK',
                children: [
                    {
                        id: 'blog', name: 'BLOG', color: '#00ffaa',
                        subs: [
                            { id: 'articles', name: 'Articles', tags: ['News', 'Tech', 'Cyber'] },
                            { id: 'notes', name: 'Notes', tags: ['Draft', 'Memo'] }
                        ]
                    }
                ]
            }
        ];

        let currentAssets = [];
        let currentMediaIndex = 0;
        let activeItem = null;
        let loadTimer = null;
        const root = document.documentElement;
        let currentParent = null;
        let currentSub = null;

        // --- UPLOAD STATE ---
        let uploadedFiles = [];
        let uploadedCover = null;

        // --- UPLOADED DATA STORAGE ---
        // Store uploaded items by category and subcategory: { "categoryId-subId": [items...] }
        let uploadedDataStore = {};

        // --- EDITOR FUNCTIONS ---
        function openEditor() {
            const panel = document.getElementById('editorPanel');
            panel.classList.add('active');

            // Populate Category Selector Dynamically
            const catSelect = document.getElementById('artCategory');
            catSelect.innerHTML = '';

            // Find the BLOG group
            const blogGroup = structure.find(g => g.group === 'NETWORK');
            if (blogGroup && blogGroup.children) {
                const blogCat = blogGroup.children.find(c => c.id === 'blog');
                if (blogCat) {
                    blogCat.subs.forEach(sub => {
                        const option = document.createElement('option');
                        option.value = `${blogCat.id}-${sub.id}`;
                        option.text = `${blogCat.name} / ${sub.name}`;
                        catSelect.appendChild(option);
                    });
                }
            }
        }

        function closeEditor() {
            document.getElementById('editorPanel').classList.remove('active');
            hideLinkPanel();
            hideResizer();
            activeMedia = null;
        }

        function execCmd(command, value = null) {
            document.execCommand(command, false, value);
            document.getElementById('editorContent').focus();
        }

        function handleImageInsert() {
            const url = prompt('Enter Image URL:');
            if (url) {
                execCmd('insertImage', url);
            }
        }

        function handlePublish() {
            const title = document.getElementById('artTitle').value.trim();
            const tags = document.getElementById('artTags').value.trim();
            const catValue = document.getElementById('artCategory').value; // "blog-articles"
            // Use uploaded cover image if available, otherwise use empty string
            const cover = articleCoverData || '';
            const content = document.getElementById('editorContent').innerHTML;

            if (!title) {
                alert('Please enter a title.');
                return;
            }

            const [catId, subId] = catValue.split('-');

            // Create New Article Asset
            const newArticle = {
                title: title,
                type: 'article',
                size: (content.length / 1024).toFixed(1) + ' KB',
                ver: 'v.1.0',
                thumbnail: cover || 'https://placehold.co/600x400/00ffaa/000?text=ARTICLE',
                sources: [], // Empty sources array for articles
                content: content, // Article content stored separately
                tag: tags.split(',')[0].trim().toUpperCase() || 'BLOG',
                description: "NEURAL LOG ENTRY"
            };

            // Store in Uploaded Data Store
            if (!uploadedDataStore[catValue]) {
                uploadedDataStore[catValue] = [];
            }
            uploadedDataStore[catValue].unshift(newArticle); // Add to top

            // Navigate to the category to see it
            // Find the category object in structure
            let foundCat, foundSub;
            structure.forEach(g => {
                g.children.forEach(c => {
                    if (c.id === catId) {
                        foundCat = c;
                        c.subs.forEach(s => {
                            if (s.id === subId) foundSub = s;
                        });
                    }
                });
            });

            if (foundCat && foundSub) {
                loadSubCategory(foundCat, foundSub);
            } else {
                // Just refresh whatever we are on, though usually we should jump
                // If we are already on the page, generateData will pick it up
            }

            closeEditor();

            // Reset Editor
            document.getElementById('artTitle').value = '';
            document.getElementById('artTags').value = '';
            clearArticleCover();
            document.getElementById('editorContent').innerHTML = '<p><br></p>';

            // Clean up global listeners
            document.removeEventListener('mousemove', resizeMedia);
            document.removeEventListener('mouseup', stopResize);
        }

        // --- ADVANCED EDITOR FUNCTIONS ---

        function toggleDropdown(id, event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            const el = document.getElementById(id);
            if (!el) return;
            const isShown = el.classList.contains('show');
            document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show'));
            if (!isShown) {
                el.classList.add('show');
            }
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.toolbar-dropdown') && 
                !event.target.closest('.dropdown-content') && 
                !event.target.closest('.color-picker-panel')) {
                document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show'));
            }
        });

        function switchColorTab(tab) {
            document.querySelectorAll('.color-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.color-grid').forEach(g => g.style.display = 'none');

            if (tab === 'fore') {
                document.querySelectorAll('.color-tab')[0].classList.add('active');
                document.getElementById('foreColorGrid').style.display = 'grid';
            } else {
                document.querySelectorAll('.color-tab')[1].classList.add('active');
                document.getElementById('backColorGrid').style.display = 'grid';
            }
        }

        const colors = [
            '#ffffff', '#000000', '#eeece1', '#1f497d', '#4f81bd', '#c0504d', '#9bbb59', '#8064a2', '#4bacc6', '#f79646',
            '#f2f2f2', '#7f7f7f', '#ddd9c3', '#c6d9f0', '#dbe5f1', '#f2dcdb', '#ebf1dd', '#e5e0ec', '#dbeef3', '#fdeada',
            '#d8d8d8', '#595959', '#c4bd97', '#8db3e2', '#b8cce4', '#e5b9b7', '#d7e3bc', '#ccc1d9', '#b7dde8', '#fbd5b5',
            '#bfbfbf', '#3f3f3f', '#938953', '#548dd4', '#95b3d7', '#d99694', '#c3d69b', '#b2a2c7', '#92cddc', '#fac08f',
            '#a5a5a5', '#262626', '#494429', '#17365d', '#366092', '#953734', '#76923c', '#5f497a', '#31859b', '#e36c09',
            '#7f7f7f', '#0c0c0c', '#1d1b10', '#0f243e', '#244061', '#632423', '#4f6128', '#3f3151', '#205867', '#974806',
            '#00f3ff', '#ff0055', '#00ffaa', '#ffcc00', '#ff9900'
        ];

        let recentColors = [];

        function initColorPicker() {
            const foreGrid = document.getElementById('foreColorGrid');
            const backGrid = document.getElementById('backColorGrid');
            if (!foreGrid || !backGrid) return;
            foreGrid.innerHTML = '';
            backGrid.innerHTML = '';
            colors.forEach(c => {
                let div = document.createElement('div');
                div.className = 'color-cell';
                div.style.backgroundColor = c;
                div.onclick = () => applyColor('foreColor', c);
                foreGrid.appendChild(div);
                div = document.createElement('div');
                div.className = 'color-cell';
                div.style.backgroundColor = c;
                div.onclick = () => applyColor('backColor', c);
                backGrid.appendChild(div);
            });
        }

        function applyColor(cmd, color) {
            execCmd(cmd, color);
            toggleDropdown('colorDropdown');
            addToRecentColors(color);
        }

        function addToRecentColors(color) {
            if (recentColors.includes(color)) return;
            recentColors.unshift(color);
            if (recentColors.length > 8) recentColors.pop();
            renderRecentColors();
        }

        function renderRecentColors() {
            const container = document.getElementById('recentColors');
            container.innerHTML = '';
            recentColors.forEach(c => {
                let div = document.createElement('div');
                div.className = 'color-cell';
                div.style.backgroundColor = c;
                div.onclick = () => {
                    const isBack = document.querySelectorAll('.color-tab')[1].classList.contains('active');
                    applyColor(isBack ? 'backColor' : 'foreColor', c);
                };
                container.appendChild(div);
            });
        }

        function triggerFileUpload(type) {
            if (type === 'image') document.getElementById('editorImgInput').click();
            if (type === 'video') document.getElementById('editorVidInput').click();
        }

        function handleEditorUpload(input, type) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                if (type === 'image') {
                    execCmd('insertImage', e.target.result);
                } else {
                    const videoHtml = `<br><video src="${e.target.result}" controls style="max-width:100%; border:1px solid var(--accent); margin:10px 0;"></video><br>`;
                    document.execCommand('insertHTML', false, videoHtml);
                }
            };
            reader.readAsDataURL(file);
            input.value = '';
        }

        function insertCodeBlock() {
            const codeHtml = `<pre style="background:rgba(0,0,0,0.5); padding:15px; border:1px solid #444; color:#0f0; font-family:'Courier New', monospace; white-space:pre-wrap;"><code>// Type your code here...</code></pre><p><br></p>`;
            document.execCommand('insertHTML', false, codeHtml);
        }

        function insertHorizontalRule() {
            const hrHtml = `<hr style="border: none; border-top: 2px solid var(--accent); margin: 20px 0; box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);"><p><br></p>`;
            document.execCommand('insertHTML', false, hrHtml);
        }

        // Article cover upload handler
        let articleCoverData = null;
        function handleArticleCoverSelect(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                articleCoverData = e.target.result;
                const preview = document.getElementById('artCoverPreview');
                const previewImg = document.getElementById('artCoverPreviewImg');
                const coverText = document.getElementById('artCoverText');
                const coverDrop = document.getElementById('artCoverDrop');
                
                previewImg.src = articleCoverData;
                preview.style.display = 'block';
                coverText.innerText = 'COVER UPLOADED';
                coverDrop.style.backgroundImage = `url(${articleCoverData})`;
                coverDrop.style.backgroundSize = 'cover';
                coverDrop.style.backgroundPosition = 'center';
            };
            reader.readAsDataURL(file);
        }

        function clearArticleCover() {
            articleCoverData = null;
            const preview = document.getElementById('artCoverPreview');
            const coverText = document.getElementById('artCoverText');
            const coverDrop = document.getElementById('artCoverDrop');
            const coverInput = document.getElementById('artCoverInput');
            
            preview.style.display = 'none';
            coverText.innerText = 'CLICK TO UPLOAD COVER';
            coverDrop.style.backgroundImage = 'none';
            if (coverInput) coverInput.value = '';
        }

        // --- CONTROLS & STATS & SOURCE ---

        let isSourceMode = false;
        let originalHTML = ''; // Store original unformatted HTML
        let isFormatted = false; // Track if current HTML is formatted

        // Convert formatted HTML back to unformatted (remove extra line breaks and indentation)
        function unformatHTML(html) {
            if (!html) return '';
            
            // Remove all formatting whitespace (line breaks, extra spaces, indentation)
            // but preserve actual HTML structure
            let text = html;
            
            // Remove all line breaks and normalize whitespace
            // Split by lines, trim each, filter empty, then join with single space
            const lines = text.split(/\r?\n/);
            const cleaned = lines
                .map(line => line.trim()) // Remove indentation
                .filter(line => line.length > 0); // Remove empty lines
            
            // Join all lines with a single space
            const joined = cleaned.join(' ');
            
            // Normalize multiple spaces to single space (but preserve spaces in attributes)
            // This regex preserves spaces within quotes
            const normalized = joined.replace(/\s+/g, ' ').trim();
            
            // Use a temporary div to parse and re-serialize HTML
            // This ensures browser-normalized HTML without extra whitespace
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = normalized;
            
            // Return the normalized innerHTML (browser will clean it up properly)
            return tempDiv.innerHTML;
        }

        function toggleSourceMode() {
            const editor = document.getElementById('editorContent');
            const source = document.getElementById('editorSource');
            const highlight = document.getElementById('editorSourceHighlight');
            const btn = document.getElementById('btnSource');

            isSourceMode = !isSourceMode;

            if (isSourceMode) {
                // Switching TO Source
                // Get current HTML from editor
                let currentHTML = editor.innerHTML;
                
                // If HTML was previously formatted, unformat it first
                if (isFormatted) {
                    currentHTML = unformatHTML(currentHTML);
                }
                
                // Store unformatted HTML
                originalHTML = currentHTML;
                
                // Format only for display
                const formatted = formatHTML(originalHTML);
                source.value = formatted;
                isFormatted = true; // Mark as formatted
                
                // Apply syntax highlighting
                highlight.innerHTML = '<pre><code class="language-html">' + escapeHtml(formatted) + '</code></pre>';
                if (typeof hljs !== 'undefined') {
                    hljs.highlightElement(highlight.querySelector('code'));
                }

                editor.style.display = 'none';
                source.style.display = 'none';
                highlight.style.display = 'block';
                btn.classList.add('active');

                // Hide floating tools
                document.getElementById('floatingToolbar').classList.remove('active');
            } else {
                // Switching TO Visual
                // Get HTML from source (may be edited)
                let html = source.value.trim();
                
                // Check if source was edited (compare with what we formatted)
                const wasFormatted = formatHTML(originalHTML);
                const wasEdited = html !== wasFormatted.trim();
                
                if (wasEdited && html) {
                    // User edited the source, unformat it before putting back
                    html = unformatHTML(html);
                } else if (!wasEdited && originalHTML) {
                    // Source wasn't edited, use original unformatted HTML
                    html = originalHTML;
                } else if (!html) {
                    // No source value, use original
                    html = originalHTML;
                }
                
                // Clear editor first to prevent browser from auto-adding paragraphs
                editor.innerHTML = '';
                
                // If HTML is empty, add a single empty paragraph
                if (!html || html.trim() === '') {
                    editor.innerHTML = '<p><br></p>';
                } else {
                    // Use Range API to insert HTML without browser auto-formatting
                    const range = document.createRange();
                    range.selectNodeContents(editor);
                    range.deleteContents();
                    
                    // Create a temporary container to parse HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    
                    // Move all nodes to editor to preserve structure exactly
                    const fragment = document.createDocumentFragment();
                    while (tempDiv.firstChild) {
                        fragment.appendChild(tempDiv.firstChild);
                    }
                    editor.appendChild(fragment);
                    
                    // Clean up any empty paragraphs that might have been added
                    const allPs = editor.querySelectorAll('p');
                    allPs.forEach(p => {
                        // Only remove if it's truly empty or just has a single br
                        const innerHTML = p.innerHTML.trim();
                        if (innerHTML === '' || innerHTML === '<br>' || innerHTML === '<br/>') {
                            // Check if it's the only child with just a br
                            const children = p.children;
                            if (children.length === 1 && children[0].tagName === 'BR') {
                                // Keep at least one empty paragraph for cursor placement
                                if (allPs.length > 1) {
                                    p.remove();
                                }
                            } else if (innerHTML === '') {
                                // Keep at least one empty paragraph for cursor placement
                                if (allPs.length > 1) {
                                    p.remove();
                                }
                            }
                        }
                    });
                }

                editor.style.display = 'block';
                source.style.display = 'none';
                highlight.style.display = 'none';
                btn.classList.remove('active');
                
                // Update original HTML to current editor content (unformatted)
                originalHTML = editor.innerHTML;
                isFormatted = false; // Mark as unformatted
                
                // Focus editor after switching
                setTimeout(() => {
                    editor.focus();
                    // Place cursor at end
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.selectNodeContents(editor);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, 50);
            }
            updateStats();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatHTML(html) {
            let text = html;

            // Add proper line breaks after closing tags
            text = text.replace(/<br\s*\/?>/g, '<br>\n');
            text = text.replace(/<\/p>/g, '</p>\n\n');
            text = text.replace(/<\/div>/g, '</div>\n');
            text = text.replace(/<\/h[1-6]>/g, (match) => match + '\n\n');
            text = text.replace(/<\/ul>/g, '</ul>\n');
            text = text.replace(/<\/ol>/g, '</ol>\n');
            text = text.replace(/<\/li>/g, '</li>\n');
            text = text.replace(/<\/pre>/g, '</pre>\n\n');

            // Add indentation for better readability
            const lines = text.split('\n');
            let indentLevel = 0;
            const indentStr = '    ';

            const formatted = lines.map(line => {
                const trimmed = line.trim();
                if (!trimmed) return '';

                // Decrease indent for closing tags
                if (trimmed.match(/^<\/(div|ul|ol|li|p|h[1-6]|pre|blockquote)/)) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }

                const result = indentStr.repeat(indentLevel) + trimmed;

                // Increase indent for opening tags (but not self-closing)
                if (trimmed.match(/^<(div|ul|ol|li|p|h[1-6]|pre|blockquote)/) && !trimmed.match(/\/>/)) {
                    indentLevel++;
                }

                return result;
            }).join('\n');

            return formatted;
        }

        function updateStats() {
            const editor = document.getElementById('editorContent');
            const text = editor.innerText || '';
            // Fix: Use character count (length) for better accuracy with non-space-separated languages (like Chinese)
            // Or use a hybrid approach. For now, total characters ignoring only whitespace is "safest" visual count.
            const wordCount = text.replace(/[\s\n\r]/g, '').length;
            const imgCount = editor.querySelectorAll('img, video').length;

            const wEl = document.getElementById('statWords');
            const iEl = document.getElementById('statImg');
            if (wEl) wEl.innerText = wordCount;
            if (iEl) iEl.innerText = imgCount;
        }

        // Update stats on keyup too
        const editorEl = document.getElementById('editorContent');
        if (editorEl) editorEl.addEventListener('keyup', updateStats);

        // Sync source editor changes and update syntax highlighting
        const sourceEl = document.getElementById('editorSource');
        const highlightEl = document.getElementById('editorSourceHighlight');
        if (sourceEl && highlightEl) {
            let highlightTimeout = null;
            sourceEl.addEventListener('input', function() {
                // Don't update originalHTML here - it's already formatted
                // originalHTML should remain unformatted
                
                // Update syntax highlighting with debounce
                clearTimeout(highlightTimeout);
                highlightTimeout = setTimeout(() => {
                    // Source value is already formatted, use it directly
                    highlightEl.innerHTML = '<pre><code class="language-html">' + escapeHtml(sourceEl.value) + '</code></pre>';
                    if (typeof hljs !== 'undefined') {
                        hljs.highlightElement(highlightEl.querySelector('code'));
                    }
                }, 300);
            });
        }



        // --- EDITOR PHASE 2: INTERACTIVE MEDIA & LINKS ---

        let activeMedia = null;
        let isResizing = false;
        let resizeStartX, resizeStartY, startWidth, startHeight;
        let activeResizeHandle = null;

        function showLinkPanel() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();

            // Only show if selection is within editor
            if (!document.getElementById('editorContent').contains(selection.anchorNode)) return;

            const panel = document.getElementById('linkPanel');

            panel.style.top = (rect.bottom + 10) + 'px';
            panel.style.left = rect.left + 'px';
            panel.classList.add('active');

            const input = document.getElementById('linkInput');
            input.value = '';
            input.focus();

            // Save range to restore later
            window.savedRange = range.cloneRange();
        }

        function hideLinkPanel() {
            document.getElementById('linkPanel').classList.remove('active');
        }

        function confirmLink() {
            const url = document.getElementById('linkInput').value;
            if (url && window.savedRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(window.savedRange);
                execCmd('createLink', url);
            }
            hideLinkPanel();
        }

        // Table Functions
        function showTablePanel() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();

            // Only show if selection is within editor
            if (!document.getElementById('editorContent').contains(selection.anchorNode)) return;

            const panel = document.getElementById('tablePanel');
            panel.style.top = (rect.bottom + 10) + 'px';
            panel.style.left = rect.left + 'px';
            panel.classList.add('active');

            // Save range to restore later
            window.savedTableRange = range.cloneRange();
        }

        function hideTablePanel() {
            document.getElementById('tablePanel').classList.remove('active');
        }

        function insertTable() {
            const rows = parseInt(document.getElementById('tableRows').value) || 3;
            const cols = parseInt(document.getElementById('tableCols').value) || 3;
            
            let tableHtml = '<table style="border-collapse: collapse; width: 100%; margin: 20px 0; border: 1px solid rgba(0, 243, 255, 0.3);">';
            
            for (let i = 0; i < rows; i++) {
                tableHtml += '<tr>';
                for (let j = 0; j < cols; j++) {
                    const cellTag = i === 0 ? 'th' : 'td';
                    tableHtml += `<${cellTag} style="border: 1px solid rgba(0, 243, 255, 0.2); padding: 8px; min-width: 50px; min-height: 30px; position: relative; background: ${i === 0 ? 'rgba(0, 243, 255, 0.1)' : 'rgba(0, 0, 0, 0.3)'};"><br></${cellTag}>`;
                }
                tableHtml += '</tr>';
            }
            tableHtml += '</table><p><br></p>';
            
            if (window.savedTableRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(window.savedTableRange);
            }
            
            document.execCommand('insertHTML', false, tableHtml);
            hideTablePanel();
            
            // Add resize handles and make table interactive
            setTimeout(() => {
                const editor = document.getElementById('editorContent');
                const insertedTable = editor.querySelector('table:last-of-type');
                if (insertedTable) {
                    initTableResize();
                    attachTableClickHandlers();
                    // Click on first cell to show toolbar
                    const firstCell = insertedTable.querySelector('td, th');
                    if (firstCell) {
                        setTimeout(() => {
                            showTableToolbar(insertedTable, firstCell);
                        }, 50);
                    }
                }
            }, 100);
        }

        function initTableResize() {
            const editor = document.getElementById('editorContent');
            const tables = editor.querySelectorAll('table');
            
            tables.forEach(table => {
                // Remove existing handles
                table.querySelectorAll('.table-resize-handle').forEach(h => h.remove());
                
                // Add column resize handles
                const firstRow = table.querySelector('tr');
                if (firstRow) {
                    const cells = firstRow.querySelectorAll('th, td');
                    cells.forEach((cell, index) => {
                        const handle = document.createElement('div');
                        handle.className = 'table-resize-handle col-resize';
                        handle.dataset.colIndex = index;
                        cell.style.position = 'relative';
                        cell.appendChild(handle);
                        
                        let isResizing = false;
                        let startX = 0;
                        let startWidth = 0;
                        
                        handle.addEventListener('mousedown', (e) => {
                            isResizing = true;
                            startX = e.clientX;
                            startWidth = cell.offsetWidth;
                            document.addEventListener('mousemove', resizeCol);
                            document.addEventListener('mouseup', stopResizeCol);
                            e.preventDefault();
                            e.stopPropagation();
                        });
                        
                        function resizeCol(e) {
                            if (!isResizing) return;
                            const diff = e.clientX - startX;
                            const newWidth = startWidth + diff;
                            if (newWidth > 30) {
                                // Resize all cells in this column
                                const allRows = table.querySelectorAll('tr');
                                allRows.forEach(row => {
                                    const targetCell = row.querySelectorAll('th, td')[index];
                                    if (targetCell) {
                                        targetCell.style.width = newWidth + 'px';
                                    }
                                });
                            }
                        }
                        
                        function stopResizeCol() {
                            isResizing = false;
                            document.removeEventListener('mousemove', resizeCol);
                            document.removeEventListener('mouseup', stopResizeCol);
                        }
                    });
                }
                
                // Add row resize handles
                const rows = table.querySelectorAll('tr');
                rows.forEach((row, index) => {
                    const firstCell = row.querySelector('th, td');
                    if (firstCell) {
                        const handle = document.createElement('div');
                        handle.className = 'table-resize-handle row-resize';
                        handle.dataset.rowIndex = index;
                        firstCell.style.position = 'relative';
                        firstCell.appendChild(handle);
                        
                        let isResizing = false;
                        let startY = 0;
                        let startHeight = 0;
                        
                        handle.addEventListener('mousedown', (e) => {
                            isResizing = true;
                            startY = e.clientY;
                            startHeight = row.offsetHeight;
                            document.addEventListener('mousemove', resizeRow);
                            document.addEventListener('mouseup', stopResizeRow);
                            e.preventDefault();
                            e.stopPropagation();
                        });
                        
                        function resizeRow(e) {
                            if (!isResizing) return;
                            const diff = e.clientY - startY;
                            const newHeight = startHeight + diff;
                            if (newHeight > 20) {
                                row.style.height = newHeight + 'px';
                            }
                        }
                        
                        function stopResizeRow() {
                            isResizing = false;
                            document.removeEventListener('mousemove', resizeRow);
                            document.removeEventListener('mouseup', stopResizeRow);
                        }
                    }
                });
            });
        }

        // Table selection state
        let tableSelectionState = {
            isSelecting: false,
            startCell: null,
            endCell: null,
            selectedCells: []
        };

        function attachTableClickHandlers() {
            const editor = document.getElementById('editorContent');
            const tables = editor.querySelectorAll('table');
            
            tables.forEach(table => {
                // Remove existing listeners by checking if already attached
                if (!table.dataset.tableHandlerAttached) {
                    table.dataset.tableHandlerAttached = 'true';
                    
                    // Single click - show toolbar (only if not selecting)
                    table.addEventListener('click', (e) => {
                        if (e.target.closest('td, th') && !e.target.classList.contains('table-resize-handle')) {
                            const cell = e.target.closest('td, th');
                            // If Ctrl/Cmd is not pressed and not in selection mode, clear selection and show toolbar
                            if (!e.ctrlKey && !e.metaKey && !tableSelectionState.isSelecting) {
                                clearTableSelection(table);
                                showTableToolbar(table, cell);
                            }
                        }
                    });
                    
                    // Mouse down - start selection
                    table.addEventListener('mousedown', (e) => {
                        if (e.target.closest('td, th') && !e.target.classList.contains('table-resize-handle')) {
                            const cell = e.target.closest('td, th');
                            if (e.button === 0) { // Left mouse button
                                tableSelectionState.isSelecting = true;
                                tableSelectionState.startCell = cell;
                                tableSelectionState.endCell = cell;
                                clearTableSelection(table);
                                cell.classList.add('selected');
                                e.preventDefault();
                            }
                        }
                    });
                    
                    // Mouse move - extend selection
                    table.addEventListener('mousemove', (e) => {
                        if (tableSelectionState.isSelecting && tableSelectionState.startCell) {
                            const cell = e.target.closest('td, th');
                            if (cell && !cell.classList.contains('table-resize-handle')) {
                                tableSelectionState.endCell = cell;
                                updateTableSelection(table);
                            }
                        }
                    });
                    
                    // Right-click context menu
                    table.addEventListener('contextmenu', (e) => {
                        if (e.target.closest('td, th') && !e.target.classList.contains('table-resize-handle')) {
                            e.preventDefault();
                            const cell = e.target.closest('td, th');
                            showTableContextMenu(table, cell, e.clientX, e.clientY);
                        }
                    });
                }
            });
        }

        // Global mouseup handler for table selection
        document.addEventListener('mouseup', (e) => {
            if (tableSelectionState.isSelecting) {
                tableSelectionState.isSelecting = false;
                // Convert selecting cells to selected
                const editor = document.getElementById('editorContent');
                const selectingCells = editor.querySelectorAll('td.selecting, th.selecting');
                selectingCells.forEach(cell => {
                    cell.classList.remove('selecting');
                    cell.classList.add('selected');
                });
                
                if (tableSelectionState.selectedCells.length > 1 || selectingCells.length > 1) {
                    // Show batch edit options
                    const selectedCells = Array.from(editor.querySelectorAll('td.selected, th.selected'));
                    if (selectedCells.length > 1) {
                        showBatchTableEditMenu(selectedCells, e.clientX, e.clientY);
                    }
                }
            }
        });

        function clearTableSelection(table) {
            const cells = table.querySelectorAll('td.selected, th.selected, td.selecting, th.selecting');
            cells.forEach(cell => {
                cell.classList.remove('selected', 'selecting');
            });
            tableSelectionState.selectedCells = [];
        }

        function updateTableSelection(table) {
            // Clear previous selecting state
            const allCells = table.querySelectorAll('td, th');
            allCells.forEach(cell => {
                cell.classList.remove('selecting');
            });
            
            if (!tableSelectionState.startCell || !tableSelectionState.endCell) return;
            
            const startRow = tableSelectionState.startCell.parentElement.rowIndex;
            const startCol = Array.from(tableSelectionState.startCell.parentElement.children).indexOf(tableSelectionState.startCell);
            const endRow = tableSelectionState.endCell.parentElement.rowIndex;
            const endCol = Array.from(tableSelectionState.endCell.parentElement.children).indexOf(tableSelectionState.endCell);
            
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);
            
            const rows = table.querySelectorAll('tr');
            tableSelectionState.selectedCells = [];
            
            for (let r = minRow; r <= maxRow; r++) {
                const row = rows[r];
                if (row) {
                    const cells = row.querySelectorAll('td, th');
                    for (let c = minCol; c <= maxCol; c++) {
                        if (cells[c]) {
                            cells[c].classList.add('selecting');
                            tableSelectionState.selectedCells.push(cells[c]);
                        }
                    }
                }
            }
        }

        function getSelectedCells(table) {
            if (tableSelectionState.selectedCells.length > 0) {
                return tableSelectionState.selectedCells;
            }
            return table.querySelectorAll('td.selected, th.selected');
        }

        function showBatchTableEditMenu(selectedCells, x, y) {
            // Update context menu to work with multiple cells
            const menu = document.getElementById('tableContextMenu');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');
            
            // Store selected cells for batch operations
            window.batchSelectedCells = selectedCells;
            
            // Update menu title to show selection count
            const title = menu.querySelector('.context-menu-title');
            if (title && selectedCells.length > 1) {
                const originalTitle = title.dataset.originalTitle || title.innerText;
                title.dataset.originalTitle = originalTitle;
                title.innerText = `SELECTED: ${selectedCells.length} CELLS`;
            }
        }

        function showTableToolbar(table, cell) {
            const toolbar = document.getElementById('tableToolbar');
            const rect = cell.getBoundingClientRect();
            
            toolbar.style.top = (rect.bottom + 10) + 'px';
            toolbar.style.left = rect.left + 'px';
            toolbar.classList.add('active');
            toolbar.dataset.tableId = Array.from(document.querySelectorAll('table')).indexOf(table);
            toolbar.dataset.cellRow = Array.from(cell.parentElement.parentElement.children).indexOf(cell.parentElement);
            toolbar.dataset.cellCol = Array.from(cell.parentElement.children).indexOf(cell);
        }

        function hideTableToolbar() {
            document.getElementById('tableToolbar').classList.remove('active');
        }

        function getCurrentTable() {
            const toolbar = document.getElementById('tableToolbar');
            if (!toolbar.classList.contains('active')) return null;
            const tables = document.querySelectorAll('#editorContent table');
            const tableIndex = parseInt(toolbar.dataset.tableId);
            return tables[tableIndex] || null;
        }

        function getCurrentCell() {
            const toolbar = document.getElementById('tableToolbar');
            if (!toolbar.classList.contains('active')) return null;
            const table = getCurrentTable();
            if (!table) return null;
            const rowIndex = parseInt(toolbar.dataset.cellRow);
            const colIndex = parseInt(toolbar.dataset.cellCol);
            const row = table.rows[rowIndex];
            return row ? row.cells[colIndex] : null;
        }

        function tableAddRow(position) {
            const cell = getCurrentCell();
            if (!cell) return;
            const row = cell.parentElement;
            const table = row.parentElement;
            const newRow = row.cloneNode(true);
            newRow.querySelectorAll('td, th').forEach(c => {
                c.innerHTML = '<br>';
                c.tagName = 'TD';
            });
            
            if (position === 'above') {
                table.insertBefore(newRow, row);
            } else {
                table.insertBefore(newRow, row.nextSibling);
            }
            initTableResize();
        }

        function tableAddCol(position) {
            const cell = getCurrentCell();
            if (!cell) return;
            const colIndex = Array.from(cell.parentElement.children).indexOf(cell);
            const table = cell.closest('table');
            const rows = table.querySelectorAll('tr');
            
            rows.forEach((row, index) => {
                const newCell = document.createElement(index === 0 ? 'th' : 'td');
                newCell.innerHTML = '<br>';
                newCell.style.border = '1px solid rgba(0, 243, 255, 0.2)';
                newCell.style.padding = '8px';
                newCell.style.minWidth = '50px';
                newCell.style.minHeight = '30px';
                newCell.style.position = 'relative';
                newCell.style.background = index === 0 ? 'rgba(0, 243, 255, 0.1)' : 'rgba(0, 0, 0, 0.3)';
                
                if (position === 'left') {
                    row.insertBefore(newCell, row.cells[colIndex]);
                } else {
                    row.insertBefore(newCell, row.cells[colIndex + 1]);
                }
            });
            initTableResize();
        }

        function tableDeleteRow() {
            const cell = getCurrentCell();
            if (!cell) return;
            const row = cell.parentElement;
            const table = row.parentElement;
            if (table.rows.length > 1) {
                row.remove();
                hideTableToolbar();
            }
        }

        function tableDeleteCol() {
            const cell = getCurrentCell();
            if (!cell) return;
            const colIndex = Array.from(cell.parentElement.children).indexOf(cell);
            const table = cell.closest('table');
            const rows = table.querySelectorAll('tr');
            
            if (rows[0] && rows[0].cells.length > 1) {
                rows.forEach(row => {
                    if (row.cells[colIndex]) {
                        row.cells[colIndex].remove();
                    }
                });
                hideTableToolbar();
            }
        }

        function tableDeleteTable() {
            const table = getCurrentTable();
            if (table) {
                table.remove();
                hideTableToolbar();
            }
        }

        // Close table toolbar when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.table-toolbar') && !e.target.closest('table')) {
                hideTableToolbar();
            }
            if (!e.target.closest('.table-context-menu') && !e.target.closest('table')) {
                hideTableContextMenu();
            }
        });

        // Table Context Menu Functions
        let currentTableContext = { table: null, cell: null };

        function showTableContextMenu(table, cell, x, y) {
            const menu = document.getElementById('tableContextMenu');
            currentTableContext.table = table;
            currentTableContext.cell = cell;
            
            // Update input values based on current cell/row/column
            const row = cell.parentElement;
            const rowHeight = row.style.height ? parseInt(row.style.height) : row.offsetHeight;
            const colWidth = cell.style.width ? parseInt(cell.style.width) : cell.offsetWidth;
            
            document.getElementById('tableRowHeight').value = rowHeight;
            document.getElementById('tableColWidth').value = colWidth;
            
            // Check if there are selected cells
            const editor = document.getElementById('editorContent');
            const selectedCells = editor.querySelectorAll('td.selected, th.selected');
            if (selectedCells.length > 1) {
                window.batchSelectedCells = Array.from(selectedCells);
            } else {
                window.batchSelectedCells = null;
            }
            
            // Position menu
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');
            
            // Update menu title if multiple cells selected
            const titles = menu.querySelectorAll('.context-menu-title');
            if (titles.length > 0 && window.batchSelectedCells && window.batchSelectedCells.length > 1) {
                titles[0].innerText = `SELECTED: ${window.batchSelectedCells.length} CELLS`;
            }
            
            // Initialize color picker if not already done
            initTableColorPicker();
        }

        function hideTableContextMenu() {
            document.getElementById('tableContextMenu').classList.remove('active');
        }

        function initTableColorPicker() {
            const picker = document.getElementById('tableColorPicker');
            if (picker.dataset.initialized === 'true') return;
            
            const colors = [
                '#000000', '#333333', '#666666', '#999999', '#cccccc', '#ffffff',
                '#ff0055', '#ff5500', '#ffaa00', '#ffff00', '#aaff00', '#00ff00',
                '#00ffaa', '#00ffff', '#00aaff', '#0055ff', '#5500ff', '#aa00ff',
                '#ff00ff', '#ff00aa', '#ff0055', '#ff5500', '#ffaa00', '#ffff00'
            ];
            
            colors.forEach(color => {
                const colorBtn = document.createElement('div');
                colorBtn.style.width = '25px';
                colorBtn.style.height = '25px';
                colorBtn.style.backgroundColor = color;
                colorBtn.style.border = '1px solid #444';
                colorBtn.style.cursor = 'pointer';
                colorBtn.style.transition = 'transform 0.2s';
                colorBtn.title = color;
                colorBtn.addEventListener('click', () => {
                    document.getElementById('tableCustomColor').value = color;
                    applyTableCellColor();
                });
                colorBtn.addEventListener('mouseenter', () => {
                    colorBtn.style.transform = 'scale(1.1)';
                    colorBtn.style.borderColor = 'var(--accent)';
                });
                colorBtn.addEventListener('mouseleave', () => {
                    colorBtn.style.transform = 'scale(1)';
                    colorBtn.style.borderColor = '#444';
                });
                picker.appendChild(colorBtn);
            });
            
            picker.dataset.initialized = 'true';
        }

        function applyTableRowHeight() {
            const selectedCells = window.batchSelectedCells || (currentTableContext.cell ? [currentTableContext.cell] : []);
            if (selectedCells.length === 0) return;
            
            const height = parseInt(document.getElementById('tableRowHeight').value);
            if (height >= 20 && height <= 200) {
                // Get unique rows from selected cells
                const rows = new Set();
                selectedCells.forEach(cell => {
                    rows.add(cell.parentElement);
                });
                rows.forEach(row => {
                    row.style.height = height + 'px';
                });
            }
        }

        function applyTableColWidth() {
            const selectedCells = window.batchSelectedCells || (currentTableContext.cell ? [currentTableContext.cell] : []);
            if (selectedCells.length === 0) return;
            
            const width = parseInt(document.getElementById('tableColWidth').value);
            if (width >= 50 && width <= 500) {
                // Get unique columns from selected cells
                const table = selectedCells[0].closest('table');
                if (!table) return;
                
                const colIndices = new Set();
                selectedCells.forEach(cell => {
                    const row = cell.parentElement;
                    const colIndex = Array.from(row.children).indexOf(cell);
                    colIndices.add(colIndex);
                });
                
                const rows = table.querySelectorAll('tr');
                colIndices.forEach(colIndex => {
                    rows.forEach(row => {
                        const targetCell = row.cells[colIndex];
                        if (targetCell) {
                            targetCell.style.width = width + 'px';
                        }
                    });
                });
            }
        }

        function setTableCellAlign(align, scope = 'cell') {
            const selectedCells = window.batchSelectedCells || (currentTableContext.cell ? [currentTableContext.cell] : []);
            if (selectedCells.length === 0) return;
            
            if (scope === 'cell') {
                // Apply to selected cells
                selectedCells.forEach(cell => {
                    cell.style.textAlign = align;
                });
            } else if (scope === 'row') {
                // Apply to entire rows of selected cells
                const rows = new Set();
                selectedCells.forEach(cell => {
                    rows.add(cell.parentElement);
                });
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td, th');
                    cells.forEach(c => {
                        c.style.textAlign = align;
                    });
                });
            } else if (scope === 'col') {
                // Apply to entire columns of selected cells
                const table = selectedCells[0].closest('table');
                if (!table) return;
                
                const colIndices = new Set();
                selectedCells.forEach(cell => {
                    const row = cell.parentElement;
                    const colIndex = Array.from(row.children).indexOf(cell);
                    colIndices.add(colIndex);
                });
                
                const rows = table.querySelectorAll('tr');
                colIndices.forEach(colIndex => {
                    rows.forEach(row => {
                        const targetCell = row.cells[colIndex];
                        if (targetCell) {
                            targetCell.style.textAlign = align;
                        }
                    });
                });
            }
        }

        function applyTableCellColor() {
            const selectedCells = window.batchSelectedCells || (currentTableContext.cell ? [currentTableContext.cell] : []);
            if (selectedCells.length === 0) return;
            
            const color = document.getElementById('tableCustomColor').value;
            selectedCells.forEach(cell => {
                cell.style.backgroundColor = color;
            });
        }

        // Resizer Logic
        // We need to attach this listener once. Since init() is far away, we can self-invoke or check checks.
        // Better: Attach to editorContent immediately here if it exists (it does).

        const editorContentEl = document.getElementById('editorContent');
        if (editorContentEl) {
            // Initialize table resize on existing tables
            setTimeout(() => {
                initTableResize();
                attachTableClickHandlers();
            }, 500);
            
            editorContentEl.addEventListener('click', function (e) {
                if (e.target.tagName === 'IMG' || e.target.tagName === 'VIDEO') {
                    activateResizer(e.target);
                    // Prevent editing cursor from jumping inside/near potentially?
                    // e.stopPropagation(); 
                } else {
                    hideResizer();
                }
            });

            editorContentEl.addEventListener('paste', function (e) {
                e.preventDefault();
                const text = (e.clipboardData || window.clipboardData).getData('text');
                const html = (e.clipboardData || window.clipboardData).getData('text/html');

                if (html) {
                    // Basic support: insert HTML. 
                    document.execCommand('insertHTML', false, html);
                } else {
                    document.execCommand('insertText', false, text);
                }
            });
        }

        function activateResizer(target) {
            activeMedia = target;
            const overlay = document.getElementById('resizeOverlay');
            if (!overlay) return;

            updateResizerPos();
            overlay.classList.add('active');

            // Highlight alignment buttons based on current state?
        }

        function hideResizer() {
            const overlay = document.getElementById('resizeOverlay');
            if (overlay) overlay.classList.remove('active');
            activeMedia = null;
        }

        function updateResizerPos() {
            if (!activeMedia) return;
            const overlay = document.getElementById('resizeOverlay');
            // We need coords relative to .editor-main.
            // activeMedia.offsetTop/Left works if they are in the same offset context.
            // .editor-content is child of .editor-main. .editor-main is relative.
            // activeMedia is inside .editor-content.
            // .editor-content { min-height: 100% }. It doesn't have position: relative usually.
            // So activeMedia.offsetParent is likely .editor-main (since it has position:relative).
            // Let's verify. 
            // If activeMedia is floated, it still works.

            // Wait, offsetTop is relative to offsetParent.
            // If .editor-content is static, offsetParent is .editor-main.

            overlay.style.width = activeMedia.offsetWidth + 'px';
            overlay.style.height = activeMedia.offsetHeight + 'px';

            // If we use offsetTop/Left, it includes margin?
            overlay.style.top = activeMedia.offsetTop + 'px';
            overlay.style.left = activeMedia.offsetLeft + 'px';
        }

        // Drag Handles
        document.querySelectorAll('.resize-handle').forEach(h => {
            h.addEventListener('mousedown', function (e) {
                if (!activeMedia) return;
                isResizing = true;
                activeResizeHandle = e.target.getAttribute('data-corner');
                resizeStartX = e.clientX;
                resizeStartY = e.clientY;
                startWidth = activeMedia.offsetWidth;
                startHeight = activeMedia.offsetHeight;

                document.addEventListener('mousemove', resizeMedia);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
                e.stopPropagation();
            });
        });

        function resizeMedia(e) {
            if (!isResizing || !activeMedia) return;

            const dx = e.clientX - resizeStartX;
            const dy = e.clientY - resizeStartY;

            let newW = startWidth;
            let newH = startHeight;

            if (activeResizeHandle.includes('e')) newW = startWidth + dx;
            if (activeResizeHandle.includes('w')) newW = startWidth - dx;
            if (activeResizeHandle.includes('s')) newH = startHeight + dy;
            if (activeResizeHandle.includes('n')) newH = startHeight - dy;

            // Simplification: only apply to Width/Height styles.
            if (newW > 20) activeMedia.style.width = newW + 'px';
            if (newH > 20) activeMedia.style.height = newH + 'px';

            updateResizerPos();
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', resizeMedia);
            document.removeEventListener('mouseup', stopResize);
            updateResizerPos(); // Final sync
        }

        function setMediaAlign(align) {
            if (!activeMedia) return;

            // Save width and height before clearing styles
            const savedWidth = activeMedia.style.width || activeMedia.offsetWidth + 'px';
            const savedHeight = activeMedia.style.height || activeMedia.offsetHeight + 'px';

            // Remove just alignment classes and float/margin/display styles (don't clear all styles)
            activeMedia.classList.remove('align-left', 'align-right', 'align-center', 'align-inline');
            activeMedia.style.float = '';
            activeMedia.style.display = '';
            activeMedia.style.margin = '';

            // Apply new alignment
            if (align === 'left') {
                activeMedia.classList.add('align-left');
            } else if (align === 'right') {
                activeMedia.classList.add('align-right');
            } else if (align === 'center') {
                activeMedia.classList.add('align-center');
            } else if (align === 'inline') {
                activeMedia.classList.add('align-inline');
            }

            // Restore width and height
            activeMedia.style.width = savedWidth;
            activeMedia.style.height = savedHeight;

            // Refresh position
            setTimeout(updateResizerPos, 10);
        }

        function deleteSelectedMedia() {
            if (activeMedia) {
                activeMedia.remove();
                hideResizer();
            }
        }

        // Listener for Floating Toolbar (Refined)
        document.addEventListener('selectionchange', () => {
            // If we have an active media resizing happening, hide text toolbar
            if (activeMedia) {
                document.getElementById('floatingToolbar').classList.remove('active');
                return;
            }

            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            const content = document.getElementById('editorContent');
            if (!content) return;

            if (!content.contains(selection.anchorNode)) {
                document.getElementById('floatingToolbar').classList.remove('active');
                return;
            }

            if (selection.isCollapsed) {
                document.getElementById('floatingToolbar').classList.remove('active');
                return;
            }

            // Also check if selection contains images? 
            // If it's pure text selection, show toolbar
            const toolbar = document.getElementById('floatingToolbar');
            const rect = range.getBoundingClientRect();

            // Calculate relative to viewport logic if fixed
            // If not fixed, we might need offsets. 
            // In CSS we set it to fixed.

            toolbar.style.top = (rect.top - 60) + 'px';
            toolbar.style.left = (rect.left + (rect.width / 2) - (toolbar.offsetWidth / 2)) + 'px';
            toolbar.classList.add('active');

            updateToolbarState();
        });

        // Delete/Usage handler for Media
        document.addEventListener('keydown', function (e) {
            if (activeMedia && (e.key === 'Delete' || e.key === 'Backspace')) {
                // But wait, if focus is in input... activeMedia is only set if we clicked it?
                // We should ensure we don't delete if we are editing a caption or something?
                // But typically activeMedia is the IMG/VIDEO.

                // Also ensure editor is active?
                if (document.getElementById('editorPanel').classList.contains('active')) {
                    deleteSelectedMedia();
                    e.preventDefault();
                }
            }
        });

        document.getElementById('editorContent').addEventListener('keyup', updateToolbarState);
        document.getElementById('editorContent').addEventListener('mouseup', updateToolbarState);

        function updateToolbarState() {
            const buttons = document.querySelectorAll('.tool-btn');
            buttons.forEach(btn => {
                const cmd = btn.getAttribute('data-cmd');
                if (cmd) {
                    if (document.queryCommandState(cmd)) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }

        function init() {
            renderSidebar();
            setTimeout(() => {
                const firstParent = document.querySelector('.nav-parent');
                if (firstParent) {
                    firstParent.classList.add('expanded', 'active-parent');
                    loadSubCategory(structure[0].children[0], structure[0].children[0].subs[0]);
                }
            }, 100);

            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                root.style.setProperty('--card-scale', e.target.value);
            });

            // Initialize search functionality
            initSearch();

            const filterContainer = document.getElementById('filterChecks');
            structure.forEach(group => {
                group.children.forEach(cat => {
                    const label = document.createElement('label');
                    label.className = 'filter-checkbox';
                    label.innerHTML = `<input type="checkbox" checked value="${cat.name}" onchange="updateGraphSettings()"> ${cat.name}`;
                    filterContainer.appendChild(label);
                });
            });

            initParticles();
            initUploadForm();
            initColorPicker();
        }

        // --- SEARCH FUNCTIONALITY ---
        function initSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchSuggestions = document.getElementById('searchSuggestions');
            let searchTimeout = null;

            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim().toLowerCase();

                clearTimeout(searchTimeout);

                if (query.length === 0) {
                    searchSuggestions.classList.remove('active');
                    return;
                }

                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 200);
            });

            searchInput.addEventListener('focus', () => {
                if (searchInput.value.trim().length > 0) {
                    searchSuggestions.classList.add('active');
                }
            });

            // Close suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#searchBox')) {
                    searchSuggestions.classList.remove('active');
                }
            });

            // Handle Enter key
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const query = searchInput.value.trim();
                    if (query.length > 0) {
                        executeSearch(query);
                        searchSuggestions.classList.remove('active');
                    }
                } else if (e.key === 'Escape') {
                    searchSuggestions.classList.remove('active');
                }
            });
        }

        // Get all assets from all categories and subcategories
        function getAllAssets() {
            const allAssets = [];

            structure.forEach(group => {
                group.children.forEach(category => {
                    category.subs.forEach(sub => {
                        // Get generated data for this category/subcategory
                        const assets = generateData(category, sub);
                        // Add category and sub info to each asset
                        assets.forEach(asset => {
                            allAssets.push({
                                ...asset,
                                _category: category,
                                _sub: sub,
                                _group: group.group
                            });
                        });
                    });
                });
            });

            return allAssets;
        }

        function performSearch(query) {
            const suggestions = [];

            // Search in categories
            structure.forEach(group => {
                group.children.forEach(category => {
                    if (category.name.toLowerCase().includes(query)) {
                        suggestions.push({
                            type: 'category',
                            title: category.name,
                            category: category,
                            group: group.group
                        });
                    }

                    category.subs.forEach(sub => {
                        if (sub.name.toLowerCase().includes(query)) {
                            suggestions.push({
                                type: 'subcategory',
                                title: sub.name,
                                category: category,
                                sub: sub,
                                group: group.group
                            });
                        }

                        // Search in tags
                        sub.tags.forEach(tag => {
                            if (tag.toLowerCase().includes(query)) {
                                suggestions.push({
                                    type: 'tag',
                                    title: tag,
                                    category: category,
                                    sub: sub,
                                    group: group.group
                                });
                            }
                        });
                    });
                });
            });

            // Search in ALL assets from all categories and subcategories
            const allAssets = getAllAssets();
            allAssets.forEach(asset => {
                if (asset.title.toLowerCase().includes(query) ||
                    asset.tag.toLowerCase().includes(query) ||
                    (asset.description && asset.description.toLowerCase().includes(query)) ||
                    asset.type.toLowerCase().includes(query)) {
                    suggestions.push({
                        type: 'asset',
                        title: asset.title,
                        asset: asset,
                        category: asset._category,
                        sub: asset._sub,
                        group: asset._group
                    });
                }
            });

            displaySearchSuggestions(suggestions, query);
        }

        function displaySearchSuggestions(suggestions, query) {
            const searchSuggestions = document.getElementById('searchSuggestions');
            searchSuggestions.innerHTML = '';

            if (suggestions.length === 0) {
                searchSuggestions.innerHTML = `
                    <div class="suggestion-section">
                        <div class="suggestion-item" style="cursor: default; opacity: 0.5;">
                            <div class="suggestion-item-text">No results found for "${query}"</div>
                        </div>
                    </div>
                `;
                searchSuggestions.classList.add('active');
                return;
            }

            // Group suggestions by type
            const grouped = {
                category: [],
                subcategory: [],
                tag: [],
                asset: []
            };

            suggestions.forEach(s => {
                if (grouped[s.type]) {
                    grouped[s.type].push(s);
                }
            });

            // Display categories
            if (grouped.category.length > 0) {
                const section = document.createElement('div');
                section.className = 'suggestion-section';
                section.innerHTML = '<div class="suggestion-section-title">CATEGORIES</div>';

                grouped.category.slice(0, 3).forEach(item => {
                    const elem = createSuggestionItem('📁', item.title, item.group, () => {
                        loadSubCategory(item.category, item.category.subs[0]);
                        document.getElementById('searchInput').value = '';
                        searchSuggestions.classList.remove('active');
                    });
                    section.appendChild(elem);
                });

                searchSuggestions.appendChild(section);
            }

            // Display subcategories
            if (grouped.subcategory.length > 0) {
                const section = document.createElement('div');
                section.className = 'suggestion-section';
                section.innerHTML = '<div class="suggestion-section-title">SUBCATEGORIES</div>';

                grouped.subcategory.slice(0, 3).forEach(item => {
                    const elem = createSuggestionItem('📂', item.title, `${item.category.name} / ${item.sub.name}`, () => {
                        loadSubCategory(item.category, item.sub);
                        document.getElementById('searchInput').value = '';
                        searchSuggestions.classList.remove('active');
                    });
                    section.appendChild(elem);
                });

                searchSuggestions.appendChild(section);
            }

            // Display tags
            if (grouped.tag.length > 0) {
                const section = document.createElement('div');
                section.className = 'suggestion-section';
                section.innerHTML = '<div class="suggestion-section-title">TAGS</div>';

                // Remove duplicates
                const uniqueTags = [...new Set(grouped.tag.map(t => t.title))];
                uniqueTags.slice(0, 5).forEach(tagName => {
                    const item = grouped.tag.find(t => t.title === tagName);
                    const elem = createSuggestionItem('🏷️', tagName, `Filter by tag`, () => {
                        if (item.category && item.sub) {
                            loadSubCategory(item.category, item.sub);
                            // Filter by tag
                            setTimeout(() => {
                                const filtered = currentAssets.filter(a => a.tag === tagName.toUpperCase());
                                renderGrid(filtered);
                                // Update filter chips
                                document.querySelectorAll('.filter-chip').forEach(c => {
                                    c.classList.remove('active');
                                    if (c.innerText === tagName) {
                                        c.classList.add('active');
                                    }
                                });
                            }, 100);
                        }
                        document.getElementById('searchInput').value = '';
                        searchSuggestions.classList.remove('active');
                    });
                    section.appendChild(elem);
                });

                searchSuggestions.appendChild(section);
            }

            // Display assets
            if (grouped.asset.length > 0) {
                const section = document.createElement('div');
                section.className = 'suggestion-section';
                section.innerHTML = '<div class="suggestion-section-title">ASSETS</div>';

                grouped.asset.slice(0, 5).forEach(item => {
                    const typeIcon = item.asset.type === 'image' ? '🖼️' :
                        item.asset.type === 'video' ? '🎬' :
                            item.asset.type === 'audio' ? '🎵' :
                                item.asset.type === 'model' ? '📦' :
                                    item.asset.type === 'pdf' ? '📄' : '📎';
                    const categoryInfo = item.category && item.sub ? `${item.category.name} / ${item.sub.name}` : '';
                    const meta = categoryInfo ? `${item.asset.type.toUpperCase()} • ${categoryInfo}` : `${item.asset.type.toUpperCase()} • ${item.asset.size}`;
                    const elem = createSuggestionItem(typeIcon, item.title, meta, () => {
                        if (item.category && item.sub) {
                            loadSubCategory(item.category, item.sub);
                            setTimeout(() => {
                                openModal(item.asset);
                            }, 200);
                        }
                        document.getElementById('searchInput').value = '';
                        searchSuggestions.classList.remove('active');
                    });
                    section.appendChild(elem);
                });

                searchSuggestions.appendChild(section);
            }

            searchSuggestions.classList.add('active');
        }

        function createSuggestionItem(icon, title, meta, onClick) {
            const item = document.createElement('div');
            item.className = 'suggestion-item';
            item.innerHTML = `
                <div class="suggestion-item-icon">${icon}</div>
                <div class="suggestion-item-text">${title}</div>
                <div class="suggestion-item-meta">${meta}</div>
            `;
            item.onclick = onClick;
            return item;
        }

        function executeSearch(query) {
            // Perform full search across ALL assets from all categories
            const allAssets = getAllAssets();
            const filtered = allAssets.filter(asset => {
                return asset.title.toLowerCase().includes(query) ||
                    asset.tag.toLowerCase().includes(query) ||
                    (asset.description && asset.description.toLowerCase().includes(query)) ||
                    asset.type.toLowerCase().includes(query);
            });

            if (filtered.length > 0) {
                // Store search results with category info for navigation
                const searchResults = filtered.map(asset => ({
                    ...asset,
                    _category: asset._category,
                    _sub: asset._sub,
                    _group: asset._group
                }));

                // Render search results
                renderSearchResults(searchResults);
            } else {
                // Show message if no results
                const grid = document.getElementById('grid');
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px; color: #666;">
                        <div style="font-size: 48px; margin-bottom: 20px; opacity: 0.3;">🔍</div>
                        <div style="font-size: 14px; color: var(--accent); margin-bottom: 10px;">NO RESULTS FOUND</div>
                        <div style="font-size: 11px;">Try searching for categories, tags, or asset names</div>
                    </div>
                `;
            }
        }

        function renderSearchResults(results) {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';

            // Update page title to show search results
            document.getElementById('pageTitle').innerHTML = `SEARCH RESULTS<span class="page-subtitle">/ ${results.length} ITEMS</span>`;

            // Group results by category for better organization
            const grouped = {};
            results.forEach(asset => {
                const key = `${asset._category.name} / ${asset._sub.name}`;
                if (!grouped[key]) {
                    grouped[key] = {
                        category: asset._category,
                        sub: asset._sub,
                        assets: []
                    };
                }
                grouped[key].assets.push(asset);
            });

            // Render each group
            Object.keys(grouped).forEach(groupKey => {
                const group = grouped[groupKey];

                // Add category header
                const header = document.createElement('div');
                header.style.cssText = 'grid-column: 1 / -1; padding: 20px 0 10px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 20px;';
                header.innerHTML = `
                    <div style="font-size: 12px; color: var(--accent); letter-spacing: 2px; margin-bottom: 5px;">${group.category.name} / ${group.sub.name}</div>
                    <div style="font-size: 10px; color: #666;">${group.assets.length} item(s)</div>
                `;
                grid.appendChild(header);

                // Render assets in this group
                group.assets.forEach((item, index) => {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.style.animation = `slideDown 0.4s ease-out ${index * 0.05}s backwards`;
                    card.onclick = () => {
                        // Navigate to the category first, then open modal
                        loadSubCategory(group.category, group.sub);
                        setTimeout(() => {
                            openModal(item);
                        }, 300);
                    };

                    let typeBadge = item.type.toUpperCase();
                    if (item.type === 'gallery' && item.sources && item.sources.length > 0) {
                        typeBadge = 'GALLERY (' + item.sources.length + ')';
                    }

                    card.innerHTML = `
                        <div class="card-type-badge">${typeBadge}</div>
                        <div class="card-cover"><div class="card-scan"></div><img src="${item.thumbnail}" class="card-img" loading="lazy"></div>
                        <div class="card-body">
                            <div class="card-title">${item.title}</div>
                            <div class="tag-row"><span class="tag-tiny">${item.tag}</span><span class="tag-tiny">SECURE</span></div>
                            <div class="card-footer"><div>SIZE<span class="stat-val">${item.size}</span></div><div>VER<span class="stat-val">${item.ver}</span></div></div>
                        </div>
                    `;
                    grid.appendChild(card);
                });
            });
        }

        function renderSidebar() {
            const nav = document.getElementById('navList');
            nav.innerHTML = '';
            structure.forEach(group => {
                const groupHeader = document.createElement('div');
                groupHeader.className = 'nav-group-header';
                groupHeader.innerText = group.group;
                nav.appendChild(groupHeader);
                group.children.forEach(parent => {
                    const parentEl = document.createElement('div');
                    parentEl.className = 'nav-parent';
                    const header = document.createElement('div');
                    header.className = 'nav-parent-header';
                    header.innerHTML = `<span>${parent.name}</span><span>+</span>`;
                    header.onclick = () => {
                        const isExpanded = parentEl.classList.contains('expanded');
                        document.querySelectorAll('.nav-parent').forEach(p => p.classList.remove('expanded', 'active-parent'));
                        if (!isExpanded) {
                            parentEl.classList.add('expanded', 'active-parent');
                            if (parent.subs.length > 0) loadSubCategory(parent, parent.subs[0]);
                        }
                    };
                    const subList = document.createElement('div');
                    subList.className = 'nav-sub-list';
                    parent.subs.forEach(sub => {
                        const item = document.createElement('div');
                        item.className = 'nav-sub-item';
                        item.innerText = sub.name;
                        item.onclick = (e) => { e.stopPropagation(); loadSubCategory(parent, sub); };
                        subList.appendChild(item);
                    });
                    parentEl.appendChild(header);
                    parentEl.appendChild(subList);
                    nav.appendChild(parentEl);
                });
            });
        }

        function loadSubCategory(parent, sub) {
            currentParent = parent;
            currentSub = sub;
            root.style.setProperty('--accent', parent.color);
            root.style.setProperty('--border-glow', parent.color + '66');
            document.getElementById('pageTitle').innerHTML = `${parent.name}<span class="page-subtitle">/ ${sub.name}</span>`;

            // Expand the parent category in sidebar
            document.querySelectorAll('.nav-parent').forEach(p => {
                const headerText = p.querySelector('.nav-parent-header span')?.innerText;
                if (headerText === parent.name) {
                    p.classList.add('expanded', 'active-parent');
                } else {
                    p.classList.remove('expanded', 'active-parent');
                }
            });

            document.querySelectorAll('.nav-sub-item').forEach(el => {
                el.classList.remove('active');
                if (el.innerText === sub.name) el.classList.add('active');
            });
            currentAssets = generateData(parent, sub);
            renderGrid(currentAssets);
            renderFilters(sub.tags);
        }

        function generateData(parent, sub) {
            const arr = [];
            // First, add uploaded items for this category/subcategory
            const storeKey = `${parent.id}-${sub.id}`;
            if (uploadedDataStore[storeKey] && uploadedDataStore[storeKey].length > 0) {
                arr.push(...uploadedDataStore[storeKey]);
            }
            // Then add generated mock data
            for (let i = 0; i < 6; i++) {
                const tag = sub.tags[i % sub.tags.length];
                let type = 'image';
                let sources = [`https://picsum.photos/seed/${sub.id}${i}/800/600`];

                // Content Type Logic
                if (sub.id === 'video' && i < 3) {
                    type = 'video';
                    sources = ['https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'];
                }
                else if (sub.id === 'gallery') {
                    type = 'gallery';
                    sources = [
                        `https://picsum.photos/seed/${sub.id}${i}a/800/600`,
                        `https://picsum.photos/seed/${sub.id}${i}b/800/600`,
                        `https://picsum.photos/seed/${sub.id}${i}c/800/600`
                    ];
                }
                else if (sub.id === 'manuals') {
                    type = 'pdf';
                    sources = ['https://pdfobject.com/pdf/sample.pdf'];
                }
                else if (sub.id === 'logs' && parent.id === 'docs') { // Differentiate logs from audio logs
                    type = 'txt';
                    sources = ['LOG_DATA'];
                }
                else if (sub.id === 'vehicles' || sub.id === 'chars') {
                    type = 'model';
                    sources = ['MOCK_3D_MODEL'];
                }
                else if (parent.id === 'audio') {
                    type = 'audio';
                    // Use working free audio samples
                    // Reliable HTTPS Audio Samples (Free Music Archive / similar)
                    const audioSamples = [
                        'https://files.freemusicarchive.org/storage-freemusicarchive-org/music/no_curator/Tours/Enthusiast/Tours_-_01_-_Enthusiast.mp3',
                        'https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Chad_Crouch/Arps/Chad_Crouch_-_Elipses.mp3',
                        'https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Lobo_Loco/Vagabond/Lobo_Loco_-_06_-_Kick_Push_Vagabond.mp3',
                        'https://files.freemusicarchive.org/storage-freemusicarchive-org/music/no_curator/Tours/Enthusiast/Tours_-_01_-_Enthusiast.mp3',
                        'https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Chad_Crouch/Arps/Chad_Crouch_-_Elipses.mp3',
                        'https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Lobo_Loco/Vagabond/Lobo_Loco_-_06_-_Kick_Push_Vagabond.mp3',
                    ];
                    sources = [audioSamples[i % audioSamples.length]];

                    // Add mock metadata
                    const meta = [
                        { dur: 185, fmt: 'MP3', br: '320 kbps' },
                        { dur: 240, fmt: 'MP3', br: '320 kbps' },
                        { dur: 156, fmt: 'MP3', br: '192 kbps' },
                        { dur: 302, fmt: 'MP3', br: '320 kbps' },
                        { dur: 215, fmt: 'MP3', br: '256 kbps' },
                        { dur: 198, fmt: 'MP3', br: '320 kbps' }
                    ];
                    const m = meta[i % meta.length];

                    // Assign to object (accessed by item.duration, etc)
                    // We need to attach these to the *object* being created, 
                    // but here we are inside the structure loop calculating props.
                    // The 'newEntry' is created a few lines later.
                    // Wait, looking at the code structure...
                    // The 'sources', 'type', 'thumb' are local vars used to create 'newEntry' at line 1735 approx.
                    // I need to export these values or allow 'newEntry' to have them.

                    // We can add them to a temporary object or modify the loop to support extra props.
                    // Let's modify the push below.
                }


                // Thumbnails
                let thumb = sources[0];
                if (type === 'video') thumb = `https://picsum.photos/seed/${sub.id}${i}/400/300?blur=2`;
                if (type === 'pdf') thumb = `https://placehold.co/400x300/1a1a1a/FFF?text=PDF+DOC`;
                if (type === 'txt') thumb = `https://placehold.co/400x300/000/00f3ff?text=TXT+LOG&font=monospace`;
                if (type === 'model') {
                    thumb = generate3DThumbnail(i);
                }
                if (type === 'audio') {
                    // Audio waveform placeholder
                    thumb = `https://placehold.co/400x300/101015/ff0055?text=AUDIO+WAVE&font=monospace`;
                }

                const entry = {
                    title: `${sub.name}_${type.toUpperCase()}_${i + 100}`,
                    type: type,
                    thumbnail: thumb, // Changed from 'thumb' to 'thumbnail' to match existing structure
                    sources: sources,
                    tag: tag, // Changed from 'tags' to 'tag' to match existing structure
                    size: (Math.random() * 400 + 10).toFixed(1) + ' MB', // Kept original size calculation
                    ver: 'v.' + (Math.random() * 5 + 1).toFixed(1) // Kept original ver calculation
                };

                if (type === 'model') {
                    entry.polyCount = Math.floor(Math.random() * 50000 + 1000); // Kept original calculation
                    entry.vertCount = Math.floor(Math.random() * 30000 + 500); // Kept original calculation
                }
                if (type === 'audio') {
                    // entry.duration = ... (Removed to use actual metadata)
                    // entry.bitrate = ... (Removed to use actual metadata)
                    entry.fmt = 'MP3'; // Default to MP3 for these samples
                }

                arr.push(entry);
            }
            return arr;
        }

        // Generate 3D Model Thumbnail
        function generate3DThumbnail(seed) {
            // Use reliable 3D render images
            const modelPreviews = [
                'https://images.unsplash.com/photo-1635070041078-e363dbe005cb?w=400&h=300&fit=crop&q=80',
                'https://images.unsplash.com/photo-1614729939124-032f0b8f4d5d?w=400&h=300&fit=crop&q=80',
                'https://images.unsplash.com/photo-1620641788421-7a1c342ea42e?w=400&h=300&fit=crop&q=80',
                'https://images.unsplash.com/photo-1551269901-5c5e14c25df7?w=400&h=300&fit=crop&q=80',
                'https://images.unsplash.com/photo-1542751371-adc38448a05e?w=400&h=300&fit=crop&q=80',
                'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=400&h=300&fit=crop&q=80',
            ];

            return modelPreviews[seed % modelPreviews.length];
        }

        function renderFilters(tags) {
            const container = document.getElementById('filterContainer');
            container.innerHTML = '';
            const allBtn = document.createElement('div');
            allBtn.className = 'filter-chip active';
            allBtn.innerText = 'ALL_DATA';
            allBtn.onclick = () => {
                renderGrid(currentAssets);
                document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                allBtn.classList.add('active');
            };
            container.appendChild(allBtn);
            tags.forEach(tag => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.innerText = tag;
                chip.onclick = () => {
                    const filtered = currentAssets.filter(item => item.tag === tag);
                    renderGrid(filtered);
                    document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                };
                container.appendChild(chip);
            });
        }

        function renderGrid(data) {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            data.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.style.animation = `slideDown 0.4s ease-out ${index * 0.05}s backwards`;
                card.onclick = () => openModal(item);
                let typeBadge = item.type.toUpperCase();
                if (item.type === 'gallery' && item.sources && item.sources.length > 0) {
                    typeBadge = 'GALLERY (' + item.sources.length + ')';
                }

                card.innerHTML = `
                    <div class="card-type-badge">${typeBadge}</div>
                    <div class="card-cover"><div class="card-scan"></div><img src="${item.thumbnail}" class="card-img" loading="lazy"></div>
                    <div class="card-body">
                        <div class="card-title">${item.title}</div>
                        <div class="tag-row"><span class="tag-tiny">${item.tag}</span><span class="tag-tiny">SECURE</span></div>
                        <div class="card-footer"><div>SIZE<span class="stat-val">${item.size}</span></div><div>VER<span class="stat-val">${item.ver}</span></div></div>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        function openModal(item) {
            activeItem = item; currentMediaIndex = 0;
            const modal = document.getElementById('modal');
            const container = document.getElementById('mediaContainer');
            document.getElementById('modalTitle').innerText = item.title;
            document.getElementById('modalSize').innerText = item.size;
            document.getElementById('modalVer').innerText = item.ver;
            document.getElementById('modalType').innerText = item.type.toUpperCase();
            document.getElementById('btnPrev').style.display = 'none';
            document.getElementById('btnNext').style.display = 'none';
            document.getElementById('thumbStrip').classList.remove('active');
            container.innerHTML = '';

            // Show/Hide Thumbnail Navigation
            const thumbContainer = document.getElementById('thumbStrip'); // Corrected to 'thumbStrip'
            // Check if item has sources array and multiple sources (exclude article type)
            if (item.type === 'article') {
                // Articles don't have sources, hide navigation
                thumbContainer.classList.remove('active');
                document.getElementById('btnPrev').style.display = 'none';
                document.getElementById('btnNext').style.display = 'none';
            } else if (item.sources && (item.type === 'gallery' || (item.sources.length > 1 && item.type !== 'pdf' && item.type !== 'txt' && item.type !== 'model' && item.type !== 'audio'))) {
                thumbContainer.classList.add('active'); // Use classList for 'active'
                renderThumbnails();
                document.getElementById('btnPrev').style.display = 'flex';
                document.getElementById('btnNext').style.display = 'flex';
            } else {
                thumbContainer.classList.remove('active'); // Use classList for 'active'
                document.getElementById('btnPrev').style.display = 'none';
                document.getElementById('btnNext').style.display = 'none';
            }

            // Update Stats Display for Models
            if (item.type === 'model') {
                document.getElementById('modalSize').parentElement.children[0].innerText = 'VERTICES';
                document.getElementById('modalSize').innerText = item.vertCount.toLocaleString();
                document.getElementById('modalVer').parentElement.children[0].innerText = 'FACES';
                document.getElementById('modalVer').innerText = item.vertCount.toLocaleString();
            } else if (item.type === 'audio') {
                document.getElementById('modalSize').parentElement.children[0].innerText = 'DURATION';
                document.getElementById('modalSize').innerText = formatTime(item.duration) || '--:--';
                document.getElementById('modalVer').parentElement.children[0].innerText = 'FORMAT';
                document.getElementById('modalVer').innerText = item.bitrate || 'OGG';
            } else {
                document.getElementById('modalSize').parentElement.children[0].innerText = 'SIZE';
                document.getElementById('modalVer').parentElement.children[0].innerText = 'VERSION';
            }

            renderMediaContent(item, 0);
            modal.classList.add('active');
        }

        let threeScene, threeCamera, threeRenderer, threeControls, animationId;
        let currentModelViewer = null;

        function render3DModel(container, item) {
            container.innerHTML = '';

            // Use the actual model URL from item.sources
            const modelUrl = item.sources && item.sources.length > 0 ? item.sources[0] : null;

            if (!modelUrl) {
                container.innerHTML = '<div style="color: #ff0055; padding: 20px; text-align: center;">>> ERROR: MODEL SOURCE NOT FOUND</div>';
                return;
            }

            // Check if model-viewer supports this format (GLB/GLTF work best)
            // For blob URLs, check the original filename from item if available
            let fileName = '';
            if (item.originalFileName) {
                fileName = item.originalFileName.toLowerCase();
            } else if (item.title && (item.title.includes('.glb') || item.title.includes('.gltf') ||
                item.title.includes('.obj') || item.title.includes('.fbx'))) {
                fileName = item.title.toLowerCase();
            } else if (typeof modelUrl === 'string') {
                // Try to extract from URL if it's not a blob URL
                fileName = modelUrl.toLowerCase();
            }
            const isGLB = fileName.endsWith('.glb') || fileName.endsWith('.gltf');

            if (isGLB) {
                // Use model-viewer for GLB/GLTF files (best support)
                const modelViewer = document.createElement('model-viewer');
                modelViewer.setAttribute('src', modelUrl);
                modelViewer.setAttribute('alt', item.title);
                modelViewer.setAttribute('camera-controls', '');
                modelViewer.setAttribute('auto-rotate', '');
                modelViewer.setAttribute('shadow-intensity', '1');
                modelViewer.setAttribute('shadow-softness', '0.5');
                modelViewer.setAttribute('exposure', '1');
                modelViewer.setAttribute('environment-image', 'neutral');
                modelViewer.setAttribute('camera-orbit', '45deg 55deg 4.5m');
                modelViewer.setAttribute('min-camera-orbit', 'auto auto auto');
                modelViewer.setAttribute('max-camera-orbit', 'auto auto auto');
                modelViewer.setAttribute('loading', 'eager');
                modelViewer.style.width = '100%';
                modelViewer.style.height = '100%';
                modelViewer.style.background = 'radial-gradient(circle at center, #1a1a2e 0%, #0a0a15 100%)';

                container.appendChild(modelViewer);
                currentModelViewer = modelViewer;
            } else {
                // For other formats (OBJ, FBX, etc.), show download option or use Three.js
                // For now, show a message with download option
                const wrapper = document.createElement('div');
                wrapper.style.cssText = 'width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; padding: 40px; text-align: center;';
                wrapper.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 20px;">📦</div>
                    <div style="font-size: 18px; color: var(--accent); margin-bottom: 10px;">3D MODEL DETECTED</div>
                    <div style="font-size: 12px; color: #888; margin-bottom: 30px;">Format: ${fileName ? fileName.split('.').pop().toUpperCase() : 'UNKNOWN'}</div>
                    <div style="font-size: 11px; color: #666; margin-bottom: 20px;">Model viewer supports GLB/GLTF formats.<br>For other formats, please download the file.</div>
                    <a href="${modelUrl}" download="${item.title}" style="
                        display: inline-block;
                        padding: 12px 24px;
                        background: var(--accent);
                        color: #000;
                        text-decoration: none;
                        border-radius: 4px;
                        font-weight: bold;
                        font-size: 11px;
                        letter-spacing: 1px;
                    ">DOWNLOAD MODEL</a>
                `;
                container.appendChild(wrapper);
                currentModelViewer = null;
            }

            // Handle Resize with ResizeObserver
            const resizeObserver = new ResizeObserver(() => {
                if (!modelViewer || !container) return;
                const width = container.clientWidth;
                const height = container.clientHeight;
                if (width > 0 && height > 0) {
                    modelViewer.style.width = width + 'px';
                    modelViewer.style.height = height + 'px';
                }
            });
            resizeObserver.observe(container);

            // Store for cleanup
            container._resizeObserver = resizeObserver;
            container._modelViewer = modelViewer;
        }

        let audioContext, audioAnalyser, audioSource, audioAnimationId;

        function renderAudioPlayer(container, item) {
            container.innerHTML = '';
            container.classList.add('audio-player-container');

            // --- LAYOUT SETUP ---
            const wrapper = document.createElement('div');
            wrapper.className = 'audio-interface';
            wrapper.style.cssText = `
                width: 100%; height: 100%; display: flex; flex-direction: column;
                background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
                position: relative; overflow: hidden;
            `;

            // Canvas Layer
            const canvas = document.createElement('canvas');
            canvas.className = 'audio-visualizer';
            canvas.style.cssText = 'position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1;';
            wrapper.appendChild(canvas);

            // Container for controls (minimal, floating at bottom)
            const controls = document.createElement('div');
            controls.className = 'audio-controls';
            controls.style.cssText = `
                position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
                width: 80%; padding: 15px 30px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid rgba(0, 243, 255, 0.3);
                border-radius: 4px;
                backdrop-filter: blur(5px);
                z-index: 10; display: flex; align-items: center; gap: 20px;
                box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
            `;

            // Play/Pause Button
            const playBtn = document.createElement('button');
            playBtn.className = 'cyber-btn icon-only';
            playBtn.innerHTML = '<i class="ph ph-play"></i>';
            playBtn.style.cssText = `
                font-size: 20px; width: 40px; height: 40px;
                display: flex; align-items: center; justify-content: center;
                padding: 0; 
            `;

            // Progress Bar
            const progressContainer = document.createElement('div');
            progressContainer.style.cssText = 'flex: 1; height: 4px; background: rgba(255,255,255,0.1); cursor: pointer; position: relative;';
            const progressFill = document.createElement('div');
            progressFill.style.cssText = 'height: 100%; width: 0%; background: var(--accent); box-shadow: 0 0 8px var(--accent); position: relative;';
            // Scrubber handle
            const scrubber = document.createElement('div');
            scrubber.style.cssText = 'position: absolute; right: -4px; top: -3px; width: 10px; height: 10px; background: #fff; border-radius: 50%; box-shadow: 0 0 5px #fff;';
            progressFill.appendChild(scrubber);
            progressContainer.appendChild(progressFill);

            // Volume Icon
            const volIcon = document.createElement('i');
            volIcon.className = 'ph ph-speaker-high';
            volIcon.style.color = 'var(--accent)';

            controls.appendChild(playBtn);
            controls.appendChild(progressContainer);
            controls.appendChild(volIcon);
            wrapper.appendChild(controls);
            container.appendChild(wrapper);

            // --- AUDIO LOGIC ---
            const audio = new Audio();
            audio.crossOrigin = "anonymous";
            audio.src = item.sources[0];
            audio.volume = 0.5;

            audio.onerror = (e) => {
                console.error("Audio Load Error", e);
                const title = document.getElementById('modalTitle');
                if (title) {
                    title.innerText = "AUDIO ERROR: LOAD FAILED";
                    title.style.color = "var(--c-alert)";
                }
            };

            // --- METADATA UPDATE ---
            audio.onloadedmetadata = () => {
                // Update Modal Info Panel (Right Side)
                const durVal = document.getElementById('modalSize'); // Borrowed for Duration
                const fmtVal = document.getElementById('modalVer');  // Borrowed for Format/Type

                if (durVal) {
                    durVal.parentElement.children[0].innerText = "DURATION"; // Label
                    durVal.innerText = formatTime(audio.duration);
                    durVal.style.color = "var(--accent)";
                    durVal.style.textShadow = "0 0 5px var(--accent)";
                }
                if (fmtVal) {
                    fmtVal.parentElement.children[0].innerText = "TYPE"; // Label
                    // Get extension from URL
                    const ext = item.sources[0].split('.').pop().split('?')[0].toUpperCase();
                    fmtVal.innerText = ext + " AUDIO";
                }

                // Auto-play safely
                playBtn.click();
            };

            // Progress Update
            audio.ontimeupdate = () => {
                if (audio.duration) {
                    const pct = (audio.currentTime / audio.duration) * 100;
                    progressFill.style.width = pct + '%';
                }
            };

            // Seek
            progressContainer.onclick = (e) => {
                const rect = progressContainer.getBoundingClientRect();
                const p = (e.clientX - rect.left) / rect.width;
                audio.currentTime = p * audio.duration;
            };

            // Toggle Play
            playBtn.onclick = () => {
                if (audio.paused) {
                    // Init Context on user gesture
                    initAudioContext();
                    audio.play().then(() => {
                        playBtn.innerHTML = '<i class="ph ph-pause"></i>';
                        playBtn.classList.add('active');
                    }).catch(err => console.error("Play error:", err));
                } else {
                    audio.pause();
                    playBtn.innerHTML = '<i class="ph ph-play"></i>';
                    playBtn.classList.remove('active');
                }
            };

            // --- VISUALIZER ---
            function initAudioContext() {
                if (audioContext) return;
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioCtx();
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 512; // Higher resolution
                audioSource = audioContext.createMediaElementSource(audio);
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);

                // Start Loop
                drawVisualizer();
            }

            function drawVisualizer() {
                audioAnimationId = requestAnimationFrame(drawVisualizer);

                // Resize
                canvas.width = wrapper.clientWidth;
                canvas.height = wrapper.clientHeight;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const cx = w / 2;
                const cy = h / 2;

                // Data
                const bufferLength = audioAnalyser.frequencyBinCount; // 256
                const dataArray = new Uint8Array(bufferLength);
                audioAnalyser.getByteFrequencyData(dataArray);

                // Clear
                ctx.fillStyle = '#020205'; // Deep dark background
                ctx.fillRect(0, 0, w, h);

                // --- RETRO CYBER EFFECTS ---

                // 1. Grid Background ( Perspective )
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
                ctx.lineWidth = 1;
                // Vertical lines perspective
                for (let i = -10; i <= 10; i++) {
                    ctx.moveTo(cx + i * 100, h);
                    ctx.lineTo(cx + i * 20, cy);
                }
                // Horizontal lines
                for (let i = 0; i < 10; i++) {
                    const y = cy + i * (h / 2 / 10) * i * 0.2; // Exponential spacing
                    ctx.moveTo(0, y + 20);
                    ctx.lineTo(w, y + 20);
                }
                ctx.stroke();
                ctx.restore();

                // 2. Center HUD Core
                const radius = 60;
                const pulse = (dataArray[10] / 255) * 20; // Beat reaction
                const r = radius + pulse;

                // Glowing Hexagon
                ctx.save();
                ctx.translate(cx, cy);
                ctx.strokeStyle = '#00f3ff';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00f3ff';

                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                // Inner Time (HUD)
                ctx.rotate(0); // Ensure text is straight
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px "Courier New"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 0;

                const cur = formatTime(audio.currentTime);
                ctx.fillText(cur, 0, 0);

                // "REC" like dot
                if (audio.paused) {
                    ctx.fillStyle = '#555';
                } else {
                    ctx.fillStyle = (Date.now() % 1000 < 500) ? '#ff0055' : '#550022';
                }
                ctx.beginPath();
                ctx.arc(0, 40, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();


                // 3. Symmetrical Bars
                const barWidth = 6;
                const gap = 4;
                const maxBarHeight = h * 0.5;
                const bars = 40; // Number of bars per side

                for (let i = 0; i < bars; i++) {
                    // Map low freq to center, high to edges? Or vice versa.
                    // Usually low is index 0. Let's put bass in center.
                    const val = dataArray[i * 2]; // Skip some bins
                    const p = val / 255;
                    const barH = p * maxBarHeight;

                    const xOffset = radius + 30 + (i * (barWidth + gap));

                    // Color Grad
                    const grad = ctx.createLinearGradient(0, cy - barH, 0, cy + barH);
                    grad.addColorStop(0, 'rgba(0, 243, 255, 0)');
                    grad.addColorStop(0.5, `rgba(0, 243, 255, ${p + 0.2})`);
                    grad.addColorStop(1, 'rgba(0, 243, 255, 0)');

                    ctx.fillStyle = grad;

                    // Right Side
                    ctx.fillRect(cx + xOffset, cy - barH / 2, barWidth, barH);
                    // Left Side
                    ctx.fillRect(cx - xOffset - barWidth, cy - barH / 2, barWidth, barH);

                    // Mirror effect (Top/Bottom reflection hints)
                    // ... slightly complex, let's stick to the main bars first.

                    // Little "Caps"
                    if (p > 0.1) {
                        ctx.fillStyle = '#fff';
                        // Right Cap
                        ctx.fillRect(cx + xOffset, cy - barH / 2 - 2, barWidth, 2);
                        ctx.fillRect(cx + xOffset, cy + barH / 2, barWidth, 2);
                        // Left Cap
                        ctx.fillRect(cx - xOffset - barWidth, cy - barH / 2 - 2, barWidth, 2);
                        ctx.fillRect(cx - xOffset - barWidth, cy + barH / 2, barWidth, 2);
                    }
                }

                // 4. Secondary Fills (Magenta) - High freqs
                // Draw some flying particles or lines based on high freqs
                const highFreq = dataArray[100];
                if (highFreq > 100) {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 0, 85, ${(highFreq - 100) / 155})`;
                    ctx.beginPath();
                    ctx.moveTo(0, cy);
                    ctx.lineTo(w, cy);
                    ctx.stroke();
                    ctx.restore();
                }

                // Add reference text "5D STEREO"
                ctx.font = '10px "Arial"';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'center';
                ctx.fillText("5D STEREO 360° SURROUND", cx, cy + r + 30);
            }

            // Cleanup
            container._cleanupAudio = () => {
                if (audio) { audio.pause(); audio.src = ""; }
                if (audioContext && audioContext.state !== 'closed') audioContext.close();
                if (audioAnimationId) cancelAnimationFrame(audioAnimationId);
                audioContext = null;
                audioSource = null;
                audioAnalyser = null;
            };
        }

        function formatTime(s) {
            if (isNaN(s) || !isFinite(s)) return "00:00";
            const min = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function simulateLoading(callback) {
            const loader = document.getElementById('mediaLoader');
            const bar = document.getElementById('loadBar');
            const pct = document.getElementById('loadPercent');
            loader.classList.add('active'); bar.style.width = '0%'; pct.innerText = '0%';
            let progress = 0;
            if (loadTimer) clearInterval(loadTimer);
            loadTimer = setInterval(() => {
                progress += Math.random() * 8;
                if (progress > 100) progress = 100;
                bar.style.width = progress + '%'; pct.innerText = Math.floor(progress) + '%';
                if (progress === 100) { clearInterval(loadTimer); setTimeout(() => { loader.classList.remove('active'); if (callback) callback(); }, 300); }
            }, 50);
        }

        function renderMediaContent(item, index) {
            const container = document.getElementById('mediaContainer');
            
            // Handle article type (has content instead of sources)
            if (item.type === 'article') {
                simulateLoading(() => {
                    container.innerHTML = '';
                    const wrap = document.createElement('div');
                    wrap.className = 'media-object active';
                    wrap.style.cssText = 'width: 100%; height: 100%; overflow-y: auto; padding: 40px; background: rgba(0, 0, 0, 0.3);';
                    wrap.innerHTML = item.content || '<p>No content available</p>';
                    container.appendChild(wrap);
                });
                return;
            }
            
            // For other types, use sources array
            if (!item.sources || !item.sources[index]) {
                container.innerHTML = '<div style="color: #ff0055; padding: 20px; text-align: center;">>> ERROR: SOURCE NOT FOUND</div>';
                return;
            }
            
            const src = item.sources[index];
            simulateLoading(() => {
                container.innerHTML = '';
                let element;

                if (item.type === 'video') {
                    element = document.createElement('video'); element.src = src; element.controls = true; element.autoplay = true; element.loop = true; element.className = 'media-object active';
                    container.appendChild(element);
                }
                else if (item.type === 'pdf') {
                    // PDF preview using iframe
                    element = document.createElement('iframe');
                    element.className = 'pdf-frame media-object active';
                    element.src = src + '#toolbar=0&navpanes=0';
                    element.style.width = '100%';
                    element.style.height = '100%';
                    element.style.border = 'none';
                    container.appendChild(element);
                }
                else if (item.type === 'doc') {
                    // Document files - show download option or preview if possible
                    const wrap = document.createElement('div');
                    wrap.className = 'media-object active';
                    wrap.style.cssText = 'width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; padding: 40px; text-align: center;';
                    const fileName = src.split('/').pop() || item.title;
                    const fileExt = fileName.split('.').pop().toUpperCase();
                    wrap.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 20px;">📄</div>
                        <div style="font-size: 18px; color: var(--accent); margin-bottom: 10px;">DOCUMENT FILE</div>
                        <div style="font-size: 12px; color: #888; margin-bottom: 10px;">${fileName}</div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 30px;">Format: ${fileExt}</div>
                        <a href="${src}" download="${fileName}" style="
                            display: inline-block;
                            padding: 12px 24px;
                            background: var(--accent);
                            color: #000;
                            text-decoration: none;
                            border-radius: 4px;
                            font-weight: bold;
                            font-size: 11px;
                            letter-spacing: 1px;
                        ">DOWNLOAD DOCUMENT</a>
                    `;
                    container.appendChild(wrap);
                }
                else if (item.type === 'txt') {
                    // ... (keep txt logic)
                    const wrap = document.createElement('div');
                    wrap.className = 'text-reader-container active media-object';
                    const toc = document.createElement('div'); toc.className = 'text-toc';
                    toc.innerHTML = `<div style="color:var(--accent); font-weight:bold; margin-bottom:10px;">// DIRECTORY</div>`;
                    ['0x00_HEADER', '0x01_INIT_SEQ', '0x02_BODY_LOG', '0x03_ERR_DUMP', '0x04_EOF'].forEach(chap => {
                        const row = document.createElement('div'); row.className = 'toc-item'; row.innerText = chap; toc.appendChild(row);
                    });
                    const content = document.createElement('div'); content.className = 'text-content';
                    content.innerHTML = `<h1>${item.title}</h1><p>DATE: 2077-11-02 <br>ENCRYPTION: AES-256-GCM</p><p>System diagnostics initialized...</p><p>${generateRandomLog()}</p>`;
                    wrap.appendChild(toc); wrap.appendChild(content); container.appendChild(wrap);
                }
                else if (item.type === 'model') {
                    const wrap = document.createElement('div');
                    wrap.className = 'media-object active';
                    wrap.style.width = '100%';
                    wrap.style.height = '100%';
                    wrap.style.minHeight = '500px';
                    container.appendChild(wrap);
                    // Pass the current source to render3DModel
                    const modelItem = { ...item, sources: [src] };
                    setTimeout(() => render3DModel(wrap, modelItem), 100);
                }
                else if (item.type === 'audio') {
                    const wrap = document.createElement('div');
                    wrap.className = 'media-object active';
                    wrap.style.width = '100%';
                    wrap.style.height = '100%';
                    container.appendChild(wrap);
                    setTimeout(() => renderAudioPlayer(wrap, item), 100);
                }
                else {
                    element = document.createElement('img'); element.src = src; element.className = 'media-object active';
                    container.appendChild(element);
                }
            });
            // Only update thumbnail navigation if item has sources and multiple items
            if (item.sources && item.sources.length > 1 && 
                (item.type === 'gallery' || (item.type !== 'pdf' && item.type !== 'txt' && item.type !== 'model' && item.type !== 'audio' && item.type !== 'article'))) {
                updateThumbnailActive(index);
            }
        }

        function generateRandomLog() {
            return `>> PACKET_DUMP: ${Math.random().toString(36).substring(7)} ${Math.random().toString(36).substring(7)}... [OK]`;
        }

        function renderThumbnails() {
            const strip = document.getElementById('thumbStrip'); 
            strip.innerHTML = '';
            
            // Check if item has sources
            if (!activeItem.sources || activeItem.sources.length === 0) {
                return;
            }
            
            activeItem.sources.forEach((src, idx) => {
                const thumb = document.createElement('div'); 
                thumb.className = 'thumb-item';
                if (idx === currentMediaIndex) thumb.classList.add('active');
                const img = document.createElement('img'); 
                img.src = src; 
                thumb.appendChild(img);
                thumb.onclick = () => { 
                    currentMediaIndex = idx; 
                    renderMediaContent(activeItem, currentMediaIndex); 
                };
                strip.appendChild(thumb);
            });
        }

        function updateThumbnailActive(index) {
            const thumbs = document.querySelectorAll('.thumb-item');
            thumbs.forEach((t, i) => { t.classList.toggle('active', i === index); });
        }

        function navigateMedia(direction) {
            if (!activeItem) return;
            // Articles don't have sources, so navigation doesn't apply
            if (activeItem.type === 'article' || !activeItem.sources || activeItem.sources.length === 0) {
                return;
            }
            const total = activeItem.sources.length;
            currentMediaIndex += direction;
            if (currentMediaIndex >= total) currentMediaIndex = 0;
            if (currentMediaIndex < 0) currentMediaIndex = total - 1;
            renderMediaContent(activeItem, currentMediaIndex);
        }

        function closeModal() {
            document.getElementById('modal').classList.remove('active');

            // Clean up
            const container = document.getElementById('mediaContainer');
            if (container) {
                if (container._resizeObserver) {
                    container._resizeObserver.disconnect();
                    container._resizeObserver = null;
                }
                if (container._modelViewer) {
                    container._modelViewer = null;
                }
                // Cleanup Audio
                if (container._cleanupAudio) {
                    container._cleanupAudio();
                    container._cleanupAudio = null;
                }
            }
            currentModelViewer = null;

            document.getElementById('mediaContainer').innerHTML = '';
            document.getElementById('modalPanel').classList.remove('expanded');
            document.querySelector('.expand-btn').innerText = "EXPAND";
        }

        function toggleFullscreen() {
            const panel = document.getElementById('modalPanel');
            const btn = document.querySelector('.expand-btn');
            panel.classList.toggle('expanded');
            btn.innerText = panel.classList.contains('expanded') ? "SHRINK" : "EXPAND";
        }

        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('modal').classList.contains('active')) return;
            if (e.key === 'Escape') closeModal();
            if (e.key === 'ArrowLeft') navigateMedia(-1);
            if (e.key === 'ArrowRight') navigateMedia(1);
        });

        // --- UPLOAD LOGIC ---
        function initUploadForm() {
            const catSel = document.getElementById('upCategory');
            structure.forEach((group, idx) => {
                group.children.forEach((cat, cIdx) => {
                    const opt = document.createElement('option');
                    opt.value = `${idx}-${cIdx}`;
                    opt.innerText = cat.name;
                    catSel.appendChild(opt);
                });
            });
            updateSubCats();
        }

        function updateSubCats() {
            const val = document.getElementById('upCategory').value.split('-');
            const cat = structure[val[0]].children[val[1]];
            const subSel = document.getElementById('upSub');
            subSel.innerHTML = '';
            cat.subs.forEach((sub, sIdx) => {
                const opt = document.createElement('option');
                opt.value = sIdx;
                opt.innerText = sub.name;
                subSel.appendChild(opt);
            });
        }

        function openUploadPanel() {
            document.getElementById('uploadPanel').classList.add('active');
            document.getElementById('modal').classList.add('active');
            document.getElementById('modalPanel').style.display = 'none';
            // Reset state
            uploadedFiles = [];
            uploadedCover = null;
            document.getElementById('upTitle').value = '';
            document.getElementById('upDesc').value = '';
            document.getElementById('upTags').value = '';
            document.getElementById('fileList').innerHTML = '<div style="text-align:center; color:#444; padding:20px; font-size:10px;">NO FILES SELECTED</div>';
            document.getElementById('preImg').src = 'https://placehold.co/600x400/000/00f3ff?text=NO+PREVIEW';
            const coverDrop = document.getElementById('coverDrop');
            coverDrop.style.backgroundImage = 'none';
            // Preserve the input element when resetting - get it BEFORE clearing innerHTML
            const coverInput = coverDrop.querySelector('#coverInput') || document.getElementById('coverInput');
            coverDrop.innerHTML = '<span>CLICK TO SET COVER</span>';
            // Re-add the input element if it exists
            if (coverInput) {
                coverDrop.appendChild(coverInput);
            } else {
                // If input doesn't exist, recreate it
                const newInput = document.createElement('input');
                newInput.type = 'file';
                newInput.id = 'coverInput';
                newInput.style.display = 'none';
                newInput.accept = 'image/*';
                newInput.onchange = function () { handleCoverSelect(this); };
                coverDrop.appendChild(newInput);
            }
        }

        function closeUploadPanel() {
            document.getElementById('uploadPanel').classList.remove('active');
            document.getElementById('modal').classList.remove('active');
            document.getElementById('modalPanel').style.display = 'flex';
        }

        // --- NEW UPLOAD LOGIC ---

        function handleFileSelect(input) {
            const files = Array.from(input.files);
            if (files.length === 0) return;

            uploadedFiles = [...uploadedFiles, ...files];
            renderFileList();
            updatePreview();

            // Auto-set cover from first image if not set
            if (!uploadedCover) {
                const firstImg = uploadedFiles.find(f => f.type.startsWith('image/'));
                if (firstImg) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        // Don't auto-set if user already picked one manually, but here check again
                        if (!uploadedCover) {
                            document.getElementById('preImg').src = e.target.result;
                            // Use this as cover for data
                            uploadedCover = e.target.result;
                        }
                    };
                    reader.readAsDataURL(firstImg);
                }
            }
        }

        function handleCoverSelect(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedCover = e.target.result;
                const coverDrop = document.getElementById('coverDrop');
                coverDrop.style.backgroundImage = `url(${uploadedCover})`;
                // Preserve the input element when clearing text - get it BEFORE clearing innerHTML
                const coverInput = coverDrop.querySelector('#coverInput') || document.getElementById('coverInput');
                coverDrop.innerHTML = ''; // Hide text
                // Re-add the input element if it exists
                if (coverInput) {
                    coverDrop.appendChild(coverInput);
                } else {
                    // If input doesn't exist, recreate it
                    const newInput = document.createElement('input');
                    newInput.type = 'file';
                    newInput.id = 'coverInput';
                    newInput.style.display = 'none';
                    newInput.accept = 'image/*';
                    newInput.onchange = function () { handleCoverSelect(this); };
                    coverDrop.appendChild(newInput);
                }
                updatePreview();
            };
            reader.readAsDataURL(file);
        }

        function renderFileList() {
            const list = document.getElementById('fileList');
            list.innerHTML = '';
            if (uploadedFiles.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#444; padding:20px; font-size:10px;">NO FILES SELECTED</div>';
                return;
            }

            uploadedFiles.forEach((file, idx) => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <div style="display:flex; align-items:center; gap:10px; overflow:hidden;">
                        <i class="ph ph-file-text" style="color:var(--accent)"></i>
                        <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${file.name}</span>
                    </div>
                    <div style="color:#666; font-size:9px;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                `;
                // Remove button
                const removeBtn = document.createElement('span');
                removeBtn.innerHTML = '×';
                removeBtn.style.cssText = "cursor:pointer; color:var(--c-alert); font-size:14px; margin-left:10px;";
                removeBtn.onclick = () => {
                    uploadedFiles.splice(idx, 1);
                    renderFileList();
                    updatePreview();
                };
                item.appendChild(removeBtn);
                list.appendChild(item);
            });
        }

        function updatePreview() {
            const title = document.getElementById('upTitle').value || (uploadedFiles.length > 0 ? uploadedFiles[0].name : 'UNTITLED_ASSET');
            const catVal = document.getElementById('upCategory').value.split('-');
            const category = structure[catVal[0]].children[catVal[1]];
            const desc = document.getElementById('upDesc').value;
            const tags = document.getElementById('upTags').value.split(',');

            document.getElementById('preTitle').innerText = title;
            document.getElementById('preType').innerText = category.name.toUpperCase();

            // Size
            let totalSize = uploadedFiles.reduce((acc, f) => acc + f.size, 0);
            document.getElementById('preSize').innerText = (totalSize / 1024 / 1024).toFixed(1) + ' MB';

            // Tags
            const tagContainer = document.getElementById('preTags');
            tagContainer.innerHTML = '';
            // Default tag
            const defTag = document.createElement('span'); defTag.className = 'tag-pill'; defTag.innerText = 'NEW';
            tagContainer.appendChild(defTag);

            tags.forEach(t => {
                if (t.trim()) {
                    const span = document.createElement('span');
                    span.className = 'tag-pill';
                    span.innerText = t.trim().toUpperCase();
                    tagContainer.appendChild(span);
                }
            });

            // Cover
            if (uploadedCover) {
                document.getElementById('preImg').src = uploadedCover;
            } else if (uploadedFiles.length === 0) {
                document.getElementById('preImg').src = 'https://placehold.co/600x400/000/00f3ff?text=NO+PREVIEW';
            }
        }

        function submitUpload() {
            if (uploadedFiles.length === 0) {
                alert(">> ACCESS DENIED: NO PAYLOAD DETECTED");
                return;
            }

            const customTitle = document.getElementById('upTitle').value || 'UNTITLED_ASSET';
            const catVal = document.getElementById('upCategory').value.split('-');
            const subIdx = document.getElementById('upSub').value;
            const userTags = document.getElementById('upTags').value.split(',').filter(t => t.trim() !== '');
            const userDesc = document.getElementById('upDesc').value;

            const category = structure[catVal[0]].children[catVal[1]];
            const sub = category.subs[subIdx];

            // Create blob URLs for all files
            const blobSources = uploadedFiles.map(file => URL.createObjectURL(file));

            // Determine primary type (from first file) - Enhanced detection
            let type = 'doc';
            const firstFile = uploadedFiles[0];
            const fileName = firstFile.name.toLowerCase();
            const fileType = firstFile.type.toLowerCase();

            // Model files (3D)
            if (fileName.endsWith('.glb') || fileName.endsWith('.gltf') ||
                fileName.endsWith('.obj') || fileName.endsWith('.fbx') ||
                fileName.endsWith('.dae') || fileName.endsWith('.3ds') ||
                fileName.endsWith('.ply') || fileName.endsWith('.stl')) {
                type = 'model';
            }
            // Image files
            else if (fileType.startsWith('image/')) {
                type = uploadedFiles.length > 1 ? 'gallery' : 'image';
            }
            // Video files
            else if (fileType.startsWith('video/')) {
                type = 'video';
            }
            // Audio files
            else if (fileType.startsWith('audio/')) {
                type = 'audio';
            }
            // Document files
            else if (fileName.endsWith('.pdf') || fileType.includes('pdf')) {
                type = 'pdf';
            }
            else if (fileName.endsWith('.txt') || fileName.endsWith('.log') ||
                fileType.includes('text/plain')) {
                type = 'txt';
            }
            else if (fileName.endsWith('.doc') || fileName.endsWith('.docx') ||
                fileType.includes('msword') || fileType.includes('wordprocessingml')) {
                type = 'doc';
            }
            else if (fileName.endsWith('.xls') || fileName.endsWith('.xlsx') ||
                fileType.includes('spreadsheet')) {
                type = 'doc';
            }
            // Default to doc for unknown types
            else {
                type = 'doc';
            }

            // Calculate total size
            const totalSize = uploadedFiles.reduce((acc, f) => acc + f.size, 0);

            // Generate appropriate thumbnail based on type
            let thumbnail = uploadedCover;
            if (!thumbnail) {
                if (type === 'image' || type === 'gallery') {
                    thumbnail = blobSources[0];
                } else if (type === 'model') {
                    // Use a placeholder for 3D models, or try to use cover if available
                    thumbnail = uploadedCover || `https://placehold.co/600x400/1a1a2e/00f3ff?text=3D+MODEL&font=monospace`;
                } else if (type === 'video') {
                    // Try to create a thumbnail from video (first frame)
                    thumbnail = `https://placehold.co/600x400/000/00f3ff?text=VIDEO&font=monospace`;
                } else if (type === 'audio') {
                    thumbnail = `https://placehold.co/600x400/101015/ff0055?text=AUDIO&font=monospace`;
                } else if (type === 'pdf') {
                    thumbnail = `https://placehold.co/600x400/1a1a1a/FFF?text=PDF+DOC`;
                } else if (type === 'txt') {
                    thumbnail = `https://placehold.co/600x400/000/00f3ff?text=TXT+LOG&font=monospace`;
                } else {
                    thumbnail = `https://placehold.co/600x400/000/00f3ff?text=${type.toUpperCase()}`;
                }
            }

            // Create ONE item with all sources
            const newItem = {
                title: customTitle,
                tag: userTags.length > 0 ? userTags[0].toUpperCase() : sub.tags[0],
                size: (totalSize / 1024 / 1024).toFixed(2) + ' MB',
                ver: 'v.1.0',
                type: type,
                thumbnail: thumbnail,
                sources: blobSources,
                description: userDesc || undefined,
                duration: (type === 'audio') ? 0 : undefined,
                // Store original file names for proper type detection
                originalFileName: firstFile.name
            };

            // Add model-specific metadata if available
            if (type === 'model') {
                // These could be extracted from the model file if needed
                newItem.vertCount = 0; // Could be calculated from model
                newItem.polyCount = 0; // Could be calculated from model
            }

            // Store the uploaded item
            const storeKey = `${category.id}-${sub.id}`;
            if (!uploadedDataStore[storeKey]) {
                uploadedDataStore[storeKey] = [];
            }
            uploadedDataStore[storeKey].unshift(newItem);

            // Navigate to the target category if not already there
            const isCurrentCategory = currentSub && currentSub.id === sub.id && currentParent && currentParent.id === category.id;

            if (!isCurrentCategory) {
                // Navigate to the target category
                loadSubCategory(category, sub);
            } else {
                // Already in the target category, just refresh the grid
                currentAssets = generateData(category, sub);
                renderGrid(currentAssets);
            }

            closeUploadPanel();

            // Scroll to top of grid to show the newly uploaded item
            setTimeout(() => {
                const grid = document.getElementById('grid');
                if (grid && grid.firstChild) {
                    grid.firstChild.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Add a highlight effect to the first card (newly uploaded)
                    grid.firstChild.style.outline = '2px solid var(--accent)';
                    grid.firstChild.style.outlineOffset = '4px';
                    setTimeout(() => {
                        if (grid.firstChild) {
                            grid.firstChild.style.outline = '';
                            grid.firstChild.style.outlineOffset = '';
                        }
                    }, 2000);
                }
            }, 100);

            alert(`>> UPLOAD COMPLETE: ${uploadedFiles.length} FILE(S) -> 1 ASSET CREATED`);
        }

        // --- COSMIC PARTICLES ---
        let particles = [];
        let particleCtx;
        let particleAnimFrame;

        function initParticles() {
            const canvas = document.getElementById('particleCanvas');
            particleCtx = canvas.getContext('2d');
            resizeParticles();
            window.addEventListener('resize', resizeParticles);
            for (let i = 0; i < 150; i++) particles.push(createParticle());
            animateParticles();
        }

        function createParticle() {
            return {
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                size: Math.random() * 2,
                speedX: (Math.random() - 0.5) * 0.2,
                speedY: (Math.random() - 0.5) * 0.2,
                opacity: Math.random(),
                pulse: Math.random() * 0.02
            };
        }

        function resizeParticles() {
            const canvas = document.getElementById('particleCanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function animateParticles() {
            if (!document.getElementById('particleCanvas').classList.contains('active')) {
                particleAnimFrame = requestAnimationFrame(animateParticles);
                return;
            }
            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            particleCtx.fillStyle = '#fff';
            particles.forEach(p => {
                p.x += p.speedX; p.y += p.speedY; p.opacity += p.pulse;
                if (p.opacity <= 0 || p.opacity >= 1) p.pulse *= -1;
                if (p.x < 0) p.x = window.innerWidth; if (p.x > window.innerWidth) p.x = 0;
                if (p.y < 0) p.y = window.innerHeight; if (p.y > window.innerHeight) p.y = 0;
                particleCtx.globalAlpha = p.opacity;
                particleCtx.beginPath(); particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2); particleCtx.fill();
            });
            particleAnimFrame = requestAnimationFrame(animateParticles);
        }

        function toggleParticles() {
            const active = document.getElementById('setParticles').checked;
            const canvas = document.getElementById('particleCanvas');
            if (active) canvas.classList.add('active'); else canvas.classList.remove('active');
        }

        // --- NEURAL NETWORK GRAPH LOGIC v3.0 ---
        let simulation;
        let isNeuralMode = false;
        let allNodes = [], allLinks = [];

        function toggleNeuralMode() {
            isNeuralMode = !isNeuralMode;
            const dash = document.getElementById('dashboard');
            const floor = document.getElementById('floor');
            const graph = document.getElementById('graphView');
            const particles = document.getElementById('particleCanvas');

            if (isNeuralMode) {
                dash.classList.add('hidden');
                floor.style.opacity = '0.3';
                graph.classList.add('active');
                if (document.getElementById('setParticles').checked) particles.classList.add('active');
                initGraphData();
                renderGraph();
            } else {
                dash.classList.remove('hidden');
                floor.style.opacity = '1';
                graph.classList.remove('active');
                particles.classList.remove('active');
                if (simulation) simulation.stop();
                d3.select("#graphView svg").remove();
            }
        }

        function initGraphData() {
            allNodes = [{ id: "CORE", group: "root", radius: 15, color: "#fff", img: `https://picsum.photos/seed/CORE/200/200` }];
            allLinks = [];

            structure.forEach(group => {
                group.children.forEach(cat => {
                    allNodes.push({
                        id: cat.name, group: "category", radius: 10, color: cat.color,
                        img: `https://picsum.photos/seed/${cat.name}/200/200`
                    });
                    allLinks.push({ source: "CORE", target: cat.name });

                    cat.subs.forEach(sub => {
                        const subId = sub.name;
                        allNodes.push({
                            id: subId, group: "sub", radius: 6, color: cat.color,
                            img: `https://picsum.photos/seed/${subId}/200/200`
                        });
                        allLinks.push({ source: cat.name, target: subId });

                        sub.tags.forEach(tag => {
                            const tagId = tag;
                            if (!allNodes.find(n => n.id === tagId)) {
                                allNodes.push({
                                    id: tagId,
                                    group: "tag",
                                    radius: 4,
                                    color: cat.color,
                                    parentCat: cat.name,
                                    parentSub: subId,
                                    img: `https://picsum.photos/seed/${tagId}/200/200`
                                });
                            }
                            allLinks.push({ source: subId, target: tagId });
                            allLinks.push({ source: cat.name, target: tagId });

                            for (let k = 0; k < 2; k++) {
                                const itemId = `${tag}_ITEM_${k}`;
                                const itemImg = `https://picsum.photos/seed/${tag}${k}/800/600`;

                                const itemData = {
                                    title: itemId,
                                    size: (Math.random() * 100).toFixed(1) + 'MB',
                                    ver: '1.0',
                                    type: 'image',
                                    sources: [itemImg]
                                };

                                allNodes.push({
                                    id: itemId,
                                    group: "item",
                                    radius: 2,
                                    color: cat.color,
                                    parentCat: cat.name,
                                    parentSub: subId,
                                    img: itemImg,
                                    data: itemData,
                                    parentId: tagId
                                });
                                allLinks.push({ source: tagId, target: itemId });
                                allLinks.push({ source: subId, target: itemId });
                            }
                        });
                    });
                });
            });
        }

        function updateGraphSettings() {
            renderGraph();
        }

        function updateGraphBg() {
            const color = document.getElementById('setBgColor').value;
            const graphContainer = document.getElementById('graphView');
            graphContainer.style.background = `radial-gradient(circle at center, ${color} 0%, #000 90%)`;
        }

        function renderGraph() {
            const size = document.getElementById('setImgSize').value;
            const density = document.getElementById('setDensity').value;
            const showImages = document.getElementById('setShowImages').checked;

            const activeFilters = [];
            document.querySelectorAll('#filterChecks input:checked').forEach(cb => activeFilters.push(cb.value));

            let filteredNodes = allNodes.filter(n => {
                if (n.group === 'root') return true;
                if (n.group === 'category') return activeFilters.includes(n.id);
                if (n.group === 'tag') return activeFilters.includes(n.parentCat);
                return activeFilters.includes(n.parentCat);
            });

            if (density < 100) {
                filteredNodes = filteredNodes.filter(n => {
                    if (n.group !== 'item') return true;
                    return (Math.random() * 100) < density;
                });
            }

            const nodeIds = new Set(filteredNodes.map(n => n.id));
            const filteredLinks = allLinks.filter(l => {
                const s = typeof l.source === 'object' ? l.source.id : l.source;
                const t = typeof l.target === 'object' ? l.target.id : l.target;
                return nodeIds.has(s) && nodeIds.has(t);
            });

            d3.select("#graphView svg").remove();
            const width = window.innerWidth;
            const height = window.innerHeight;

            const svg = d3.select("#graphView").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("class", showImages ? "show-images" : "")
                .call(d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

            const g = svg.append("g");

            simulation = d3.forceSimulation(filteredNodes)
                .force("link", d3.forceLink(filteredLinks).id(d => d.id).distance(d => d.group === 'item' ? 30 : 100))
                .force("charge", d3.forceManyBody().strength(d => d.group === 'item' ? -50 : -400))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide(d => d.group === 'item' ? 5 : parseInt(size) / 2 + 10));

            const link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(filteredLinks)
                .enter().append("line")
                .attr("class", "link");

            const node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(filteredNodes)
                .enter().append("g")
                .attr("class", "node-group")
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

            node.append("circle")
                .attr("class", "node-circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color);

            node.filter(d => d.img).append("image")
                .attr("class", "node-preview-img")
                .attr("href", d => d.img)
                .attr("x", -size / 2)
                .attr("y", -size / 2 - size * 0.8)
                .attr("width", size)
                .attr("height", size)
                .style("cursor", "pointer")
                .on("click", (e, d) => {
                    e.stopPropagation();
                    if (d.group === 'item') {
                        openModal(d.data);
                    } else if (d.group === 'tag') {
                        const childItems = filteredNodes.filter(n => n.parentId === d.id && n.group === 'item');
                        if (childItems.length > 0) {
                            const galleryData = {
                                title: `TAG: ${d.id}`,
                                size: 'VAR',
                                ver: '1.0',
                                type: 'gallery',
                                sources: childItems.map(c => c.data.sources[0])
                            };
                            openModal(galleryData);
                        }
                    }
                });

            node.append("text")
                .attr("class", "node-text")
                .attr("dx", 15)
                .attr("dy", 4)
                .text(d => d.group === 'item' ? '' : d.id);

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });

            const linkedByIndex = {};
            filteredLinks.forEach(d => {
                linkedByIndex[`${d.source.id},${d.target.id}`] = 1;
            });

            function isConnected(a, b) {
                return linkedByIndex[`${a.id},${b.id}`] || linkedByIndex[`${b.id},${a.id}`] || a.id === b.id;
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
                node.classed("dimmed", true); link.classed("dimmed", true);
                node.classed("highlighted", o => isConnected(d, o));
                link.classed("highlighted", o => o.source.id === d.id || o.target.id === d.id);
            }

            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null; d.fy = null;
                node.classed("dimmed", false).classed("highlighted", false);
                link.classed("dimmed", false).classed("highlighted", false);
            }
        }

        init();
    </script>
</body>

</html>